{"metadata":{"kernelspec":{"display_name":"Python 3","language":"python","name":"python3"},"language_info":{"name":"python","version":"3.10.14","mimetype":"text/x-python","codemirror_mode":{"name":"ipython","version":3},"pygments_lexer":"ipython3","nbconvert_exporter":"python","file_extension":".py"},"papermill":{"default_parameters":{},"duration":1282.712414,"end_time":"2022-06-19T13:29:49.143640","environment_variables":{},"exception":null,"input_path":"__notebook__.ipynb","output_path":"__notebook__.ipynb","parameters":{},"start_time":"2022-06-19T13:08:26.431226","version":"2.3.4"},"widgets":{"application/vnd.jupyter.widget-state+json":{"state":{"08e21b79261a4938935a10641d54aa37":{"model_module":"@jupyter-widgets/controls","model_module_version":"1.5.0","model_name":"ProgressStyleModel","state":{"_model_module":"@jupyter-widgets/controls","_model_module_version":"1.5.0","_model_name":"ProgressStyleModel","_view_count":null,"_view_module":"@jupyter-widgets/base","_view_module_version":"1.2.0","_view_name":"StyleView","bar_color":null,"description_width":""}},"09e3f12ea27b42dd85c232b6f849afe3":{"model_module":"@jupyter-widgets/base","model_module_version":"1.2.0","model_name":"LayoutModel","state":{"_model_module":"@jupyter-widgets/base","_model_module_version":"1.2.0","_model_name":"LayoutModel","_view_count":null,"_view_module":"@jupyter-widgets/base","_view_module_version":"1.2.0","_view_name":"LayoutView","align_content":null,"align_items":null,"align_self":null,"border":null,"bottom":null,"display":null,"flex":null,"flex_flow":null,"grid_area":null,"grid_auto_columns":null,"grid_auto_flow":null,"grid_auto_rows":null,"grid_column":null,"grid_gap":null,"grid_row":null,"grid_template_areas":null,"grid_template_columns":null,"grid_template_rows":null,"height":null,"justify_content":null,"justify_items":null,"left":null,"margin":null,"max_height":null,"max_width":null,"min_height":null,"min_width":null,"object_fit":null,"object_position":null,"order":null,"overflow":null,"overflow_x":null,"overflow_y":null,"padding":null,"right":null,"top":null,"visibility":null,"width":null}},"19cf67d637214b00be27d2dc3ae6dccf":{"model_module":"@jupyter-widgets/controls","model_module_version":"1.5.0","model_name":"HTMLModel","state":{"_dom_classes":[],"_model_module":"@jupyter-widgets/controls","_model_module_version":"1.5.0","_model_name":"HTMLModel","_view_count":null,"_view_module":"@jupyter-widgets/controls","_view_module_version":"1.5.0","_view_name":"HTMLView","description":"","description_tooltip":null,"layout":"IPY_MODEL_c99cd71e0bc54d8294ae107dbaa8d364","placeholder":"​","style":"IPY_MODEL_e39d4eaab323447faf8b59b99026842e","value":"Render HTML: 100%"}},"1b7fe5cefbc2406f895bfde1c1721522":{"model_module":"@jupyter-widgets/base","model_module_version":"1.2.0","model_name":"LayoutModel","state":{"_model_module":"@jupyter-widgets/base","_model_module_version":"1.2.0","_model_name":"LayoutModel","_view_count":null,"_view_module":"@jupyter-widgets/base","_view_module_version":"1.2.0","_view_name":"LayoutView","align_content":null,"align_items":null,"align_self":null,"border":null,"bottom":null,"display":null,"flex":null,"flex_flow":null,"grid_area":null,"grid_auto_columns":null,"grid_auto_flow":null,"grid_auto_rows":null,"grid_column":null,"grid_gap":null,"grid_row":null,"grid_template_areas":null,"grid_template_columns":null,"grid_template_rows":null,"height":null,"justify_content":null,"justify_items":null,"left":null,"margin":null,"max_height":null,"max_width":null,"min_height":null,"min_width":null,"object_fit":null,"object_position":null,"order":null,"overflow":null,"overflow_x":null,"overflow_y":null,"padding":null,"right":null,"top":null,"visibility":null,"width":null}},"1d733c499e7e4b319950d6a206233c93":{"model_module":"@jupyter-widgets/controls","model_module_version":"1.5.0","model_name":"HTMLModel","state":{"_dom_classes":[],"_model_module":"@jupyter-widgets/controls","_model_module_version":"1.5.0","_model_name":"HTMLModel","_view_count":null,"_view_module":"@jupyter-widgets/controls","_view_module_version":"1.5.0","_view_name":"HTMLView","description":"","description_tooltip":null,"layout":"IPY_MODEL_b66c9fcc8c724ca69c8325cddec30a0f","placeholder":"​","style":"IPY_MODEL_e5b13baf170d4511ac85cc7368c8221b","value":"100%"}},"251af20fd4f446bb85ce543c154b1c70":{"model_module":"@jupyter-widgets/controls","model_module_version":"1.5.0","model_name":"DescriptionStyleModel","state":{"_model_module":"@jupyter-widgets/controls","_model_module_version":"1.5.0","_model_name":"DescriptionStyleModel","_view_count":null,"_view_module":"@jupyter-widgets/base","_view_module_version":"1.2.0","_view_name":"StyleView","description_width":""}},"25b3dc374121442b986faa801c8ce42e":{"model_module":"@jupyter-widgets/controls","model_module_version":"1.5.0","model_name":"DescriptionStyleModel","state":{"_model_module":"@jupyter-widgets/controls","_model_module_version":"1.5.0","_model_name":"DescriptionStyleModel","_view_count":null,"_view_module":"@jupyter-widgets/base","_view_module_version":"1.2.0","_view_name":"StyleView","description_width":""}},"39ab0e1cbdad4eaab68d1f66a37abea0":{"model_module":"@jupyter-widgets/controls","model_module_version":"1.5.0","model_name":"ProgressStyleModel","state":{"_model_module":"@jupyter-widgets/controls","_model_module_version":"1.5.0","_model_name":"ProgressStyleModel","_view_count":null,"_view_module":"@jupyter-widgets/base","_view_module_version":"1.2.0","_view_name":"StyleView","bar_color":null,"description_width":""}},"49b916750ce74d8b943ea3989a22cc47":{"model_module":"@jupyter-widgets/base","model_module_version":"1.2.0","model_name":"LayoutModel","state":{"_model_module":"@jupyter-widgets/base","_model_module_version":"1.2.0","_model_name":"LayoutModel","_view_count":null,"_view_module":"@jupyter-widgets/base","_view_module_version":"1.2.0","_view_name":"LayoutView","align_content":null,"align_items":null,"align_self":null,"border":null,"bottom":null,"display":null,"flex":null,"flex_flow":null,"grid_area":null,"grid_auto_columns":null,"grid_auto_flow":null,"grid_auto_rows":null,"grid_column":null,"grid_gap":null,"grid_row":null,"grid_template_areas":null,"grid_template_columns":null,"grid_template_rows":null,"height":null,"justify_content":null,"justify_items":null,"left":null,"margin":null,"max_height":null,"max_width":null,"min_height":null,"min_width":null,"object_fit":null,"object_position":null,"order":null,"overflow":null,"overflow_x":null,"overflow_y":null,"padding":null,"right":null,"top":null,"visibility":null,"width":null}},"4df048b45d7c4f2f965dbf793911df9f":{"model_module":"@jupyter-widgets/controls","model_module_version":"1.5.0","model_name":"ProgressStyleModel","state":{"_model_module":"@jupyter-widgets/controls","_model_module_version":"1.5.0","_model_name":"ProgressStyleModel","_view_count":null,"_view_module":"@jupyter-widgets/base","_view_module_version":"1.2.0","_view_name":"StyleView","bar_color":null,"description_width":""}},"54bc87031eac41ee8ef1b3ef7911bf26":{"model_module":"@jupyter-widgets/base","model_module_version":"1.2.0","model_name":"LayoutModel","state":{"_model_module":"@jupyter-widgets/base","_model_module_version":"1.2.0","_model_name":"LayoutModel","_view_count":null,"_view_module":"@jupyter-widgets/base","_view_module_version":"1.2.0","_view_name":"LayoutView","align_content":null,"align_items":null,"align_self":null,"border":null,"bottom":null,"display":null,"flex":null,"flex_flow":null,"grid_area":null,"grid_auto_columns":null,"grid_auto_flow":null,"grid_auto_rows":null,"grid_column":null,"grid_gap":null,"grid_row":null,"grid_template_areas":null,"grid_template_columns":null,"grid_template_rows":null,"height":null,"justify_content":null,"justify_items":null,"left":null,"margin":null,"max_height":null,"max_width":null,"min_height":null,"min_width":null,"object_fit":null,"object_position":null,"order":null,"overflow":null,"overflow_x":null,"overflow_y":null,"padding":null,"right":null,"top":null,"visibility":null,"width":null}},"557dee9dc64b4dfeb2bbcbdb6c842c42":{"model_module":"@jupyter-widgets/controls","model_module_version":"1.5.0","model_name":"HTMLModel","state":{"_dom_classes":[],"_model_module":"@jupyter-widgets/controls","_model_module_version":"1.5.0","_model_name":"HTMLModel","_view_count":null,"_view_module":"@jupyter-widgets/controls","_view_module_version":"1.5.0","_view_name":"HTMLView","description":"","description_tooltip":null,"layout":"IPY_MODEL_b941729cbd63412f86d11581dccc7c0c","placeholder":"​","style":"IPY_MODEL_5b589105f1914f5aa46730bd89e53050","value":" 1/1 [00:02&lt;00:00,  2.54s/it]"}},"5b589105f1914f5aa46730bd89e53050":{"model_module":"@jupyter-widgets/controls","model_module_version":"1.5.0","model_name":"DescriptionStyleModel","state":{"_model_module":"@jupyter-widgets/controls","_model_module_version":"1.5.0","_model_name":"DescriptionStyleModel","_view_count":null,"_view_module":"@jupyter-widgets/base","_view_module_version":"1.2.0","_view_name":"StyleView","description_width":""}},"5e42fa96bf534316baaa4af927900fa5":{"model_module":"@jupyter-widgets/base","model_module_version":"1.2.0","model_name":"LayoutModel","state":{"_model_module":"@jupyter-widgets/base","_model_module_version":"1.2.0","_model_name":"LayoutModel","_view_count":null,"_view_module":"@jupyter-widgets/base","_view_module_version":"1.2.0","_view_name":"LayoutView","align_content":null,"align_items":null,"align_self":null,"border":null,"bottom":null,"display":null,"flex":null,"flex_flow":null,"grid_area":null,"grid_auto_columns":null,"grid_auto_flow":null,"grid_auto_rows":null,"grid_column":null,"grid_gap":null,"grid_row":null,"grid_template_areas":null,"grid_template_columns":null,"grid_template_rows":null,"height":null,"justify_content":null,"justify_items":null,"left":null,"margin":null,"max_height":null,"max_width":null,"min_height":null,"min_width":null,"object_fit":null,"object_position":null,"order":null,"overflow":null,"overflow_x":null,"overflow_y":null,"padding":null,"right":null,"top":null,"visibility":null,"width":null}},"5ff7602c1c6248bba3fdcc26135a4a9f":{"model_module":"@jupyter-widgets/controls","model_module_version":"1.5.0","model_name":"FloatProgressModel","state":{"_dom_classes":[],"_model_module":"@jupyter-widgets/controls","_model_module_version":"1.5.0","_model_name":"FloatProgressModel","_view_count":null,"_view_module":"@jupyter-widgets/controls","_view_module_version":"1.5.0","_view_name":"ProgressView","bar_style":"success","description":"","description_tooltip":null,"layout":"IPY_MODEL_09e3f12ea27b42dd85c232b6f849afe3","max":1,"min":0,"orientation":"horizontal","style":"IPY_MODEL_39ab0e1cbdad4eaab68d1f66a37abea0","value":1}},"5ffc5bb5e511454a8c4c8e4b07a19bf2":{"model_module":"@jupyter-widgets/controls","model_module_version":"1.5.0","model_name":"HBoxModel","state":{"_dom_classes":[],"_model_module":"@jupyter-widgets/controls","_model_module_version":"1.5.0","_model_name":"HBoxModel","_view_count":null,"_view_module":"@jupyter-widgets/controls","_view_module_version":"1.5.0","_view_name":"HBoxView","box_style":"","children":["IPY_MODEL_df9efe0bd2f344d39fafc4b5da5b5056","IPY_MODEL_e47eabbc5e6e400a848e843b9ca01a49","IPY_MODEL_781f3b89b710431585171a3ac9182ce6"],"layout":"IPY_MODEL_1b7fe5cefbc2406f895bfde1c1721522"}},"6462380cdfe34f2181208d1e038f560f":{"model_module":"@jupyter-widgets/controls","model_module_version":"1.5.0","model_name":"FloatProgressModel","state":{"_dom_classes":[],"_model_module":"@jupyter-widgets/controls","_model_module_version":"1.5.0","_model_name":"FloatProgressModel","_view_count":null,"_view_module":"@jupyter-widgets/controls","_view_module_version":"1.5.0","_view_name":"ProgressView","bar_style":"success","description":"","description_tooltip":null,"layout":"IPY_MODEL_49b916750ce74d8b943ea3989a22cc47","max":1,"min":0,"orientation":"horizontal","style":"IPY_MODEL_08e21b79261a4938935a10641d54aa37","value":1}},"6a5affa52cc4492ab8a41a7969439ce5":{"model_module":"@jupyter-widgets/controls","model_module_version":"1.5.0","model_name":"FloatProgressModel","state":{"_dom_classes":[],"_model_module":"@jupyter-widgets/controls","_model_module_version":"1.5.0","_model_name":"FloatProgressModel","_view_count":null,"_view_module":"@jupyter-widgets/controls","_view_module_version":"1.5.0","_view_name":"ProgressView","bar_style":"success","description":"","description_tooltip":null,"layout":"IPY_MODEL_da4954ff569442a485788912df7e1b94","max":10,"min":0,"orientation":"horizontal","style":"IPY_MODEL_ebfffcfaed1e4129875ef3b3e59683c2","value":10}},"6ccc3614c2be4ea39c56e6c39c89650a":{"model_module":"@jupyter-widgets/base","model_module_version":"1.2.0","model_name":"LayoutModel","state":{"_model_module":"@jupyter-widgets/base","_model_module_version":"1.2.0","_model_name":"LayoutModel","_view_count":null,"_view_module":"@jupyter-widgets/base","_view_module_version":"1.2.0","_view_name":"LayoutView","align_content":null,"align_items":null,"align_self":null,"border":null,"bottom":null,"display":null,"flex":null,"flex_flow":null,"grid_area":null,"grid_auto_columns":null,"grid_auto_flow":null,"grid_auto_rows":null,"grid_column":null,"grid_gap":null,"grid_row":null,"grid_template_areas":null,"grid_template_columns":null,"grid_template_rows":null,"height":null,"justify_content":null,"justify_items":null,"left":null,"margin":null,"max_height":null,"max_width":null,"min_height":null,"min_width":null,"object_fit":null,"object_position":null,"order":null,"overflow":null,"overflow_x":null,"overflow_y":null,"padding":null,"right":null,"top":null,"visibility":null,"width":null}},"6fe0cda4d6d24703b10536579ed7c090":{"model_module":"@jupyter-widgets/controls","model_module_version":"1.5.0","model_name":"ProgressStyleModel","state":{"_model_module":"@jupyter-widgets/controls","_model_module_version":"1.5.0","_model_name":"ProgressStyleModel","_view_count":null,"_view_module":"@jupyter-widgets/base","_view_module_version":"1.2.0","_view_name":"StyleView","bar_color":null,"description_width":""}},"781f3b89b710431585171a3ac9182ce6":{"model_module":"@jupyter-widgets/controls","model_module_version":"1.5.0","model_name":"HTMLModel","state":{"_dom_classes":[],"_model_module":"@jupyter-widgets/controls","_model_module_version":"1.5.0","_model_name":"HTMLModel","_view_count":null,"_view_module":"@jupyter-widgets/controls","_view_module_version":"1.5.0","_view_name":"HTMLView","description":"","description_tooltip":null,"layout":"IPY_MODEL_dc078b1f9a8e4e4c9b767d0f29eb783c","placeholder":"​","style":"IPY_MODEL_251af20fd4f446bb85ce543c154b1c70","value":" 1/1 [00:04&lt;00:00,  4.93s/it]"}},"799727381e2347bd8a7f7c71e2e00c26":{"model_module":"@jupyter-widgets/controls","model_module_version":"1.5.0","model_name":"HTMLModel","state":{"_dom_classes":[],"_model_module":"@jupyter-widgets/controls","_model_module_version":"1.5.0","_model_name":"HTMLModel","_view_count":null,"_view_module":"@jupyter-widgets/controls","_view_module_version":"1.5.0","_view_name":"HTMLView","description":"","description_tooltip":null,"layout":"IPY_MODEL_b71e3adbdee74a29b6a09367c8ff2c5b","placeholder":"​","style":"IPY_MODEL_e5c164d40ded4d4187d8166466bf110a","value":" 56/56 [00:09&lt;00:00,  5.05it/s, Completed]"}},"84b65176d56c429d95671536823ce83b":{"model_module":"@jupyter-widgets/controls","model_module_version":"1.5.0","model_name":"HTMLModel","state":{"_dom_classes":[],"_model_module":"@jupyter-widgets/controls","_model_module_version":"1.5.0","_model_name":"HTMLModel","_view_count":null,"_view_module":"@jupyter-widgets/controls","_view_module_version":"1.5.0","_view_name":"HTMLView","description":"","description_tooltip":null,"layout":"IPY_MODEL_95f0f7a5aebb45b68bcb1a3a4416412c","placeholder":"​","style":"IPY_MODEL_ccafad29dc2048f2872d69b0f5dd3b1c","value":" 1/1 [00:00&lt;00:00, 24.80it/s]"}},"8fa3c697e1b24507af32cdf0ac6cc0bd":{"model_module":"@jupyter-widgets/base","model_module_version":"1.2.0","model_name":"LayoutModel","state":{"_model_module":"@jupyter-widgets/base","_model_module_version":"1.2.0","_model_name":"LayoutModel","_view_count":null,"_view_module":"@jupyter-widgets/base","_view_module_version":"1.2.0","_view_name":"LayoutView","align_content":null,"align_items":null,"align_self":null,"border":null,"bottom":null,"display":null,"flex":null,"flex_flow":null,"grid_area":null,"grid_auto_columns":null,"grid_auto_flow":null,"grid_auto_rows":null,"grid_column":null,"grid_gap":null,"grid_row":null,"grid_template_areas":null,"grid_template_columns":null,"grid_template_rows":null,"height":null,"justify_content":null,"justify_items":null,"left":null,"margin":null,"max_height":null,"max_width":null,"min_height":null,"min_width":null,"object_fit":null,"object_position":null,"order":null,"overflow":null,"overflow_x":null,"overflow_y":null,"padding":null,"right":null,"top":null,"visibility":null,"width":null}},"952abf85a8804613a72aefae1152ab2b":{"model_module":"@jupyter-widgets/controls","model_module_version":"1.5.0","model_name":"DescriptionStyleModel","state":{"_model_module":"@jupyter-widgets/controls","_model_module_version":"1.5.0","_model_name":"DescriptionStyleModel","_view_count":null,"_view_module":"@jupyter-widgets/base","_view_module_version":"1.2.0","_view_name":"StyleView","description_width":""}},"95f0f7a5aebb45b68bcb1a3a4416412c":{"model_module":"@jupyter-widgets/base","model_module_version":"1.2.0","model_name":"LayoutModel","state":{"_model_module":"@jupyter-widgets/base","_model_module_version":"1.2.0","_model_name":"LayoutModel","_view_count":null,"_view_module":"@jupyter-widgets/base","_view_module_version":"1.2.0","_view_name":"LayoutView","align_content":null,"align_items":null,"align_self":null,"border":null,"bottom":null,"display":null,"flex":null,"flex_flow":null,"grid_area":null,"grid_auto_columns":null,"grid_auto_flow":null,"grid_auto_rows":null,"grid_column":null,"grid_gap":null,"grid_row":null,"grid_template_areas":null,"grid_template_columns":null,"grid_template_rows":null,"height":null,"justify_content":null,"justify_items":null,"left":null,"margin":null,"max_height":null,"max_width":null,"min_height":null,"min_width":null,"object_fit":null,"object_position":null,"order":null,"overflow":null,"overflow_x":null,"overflow_y":null,"padding":null,"right":null,"top":null,"visibility":null,"width":null}},"96ac05ac272747c0a6555e0b3eb284b4":{"model_module":"@jupyter-widgets/controls","model_module_version":"1.5.0","model_name":"HBoxModel","state":{"_dom_classes":[],"_model_module":"@jupyter-widgets/controls","_model_module_version":"1.5.0","_model_name":"HBoxModel","_view_count":null,"_view_module":"@jupyter-widgets/controls","_view_module_version":"1.5.0","_view_name":"HBoxView","box_style":"","children":["IPY_MODEL_f234691cc30a4665a8ba3f21f1509480","IPY_MODEL_6462380cdfe34f2181208d1e038f560f","IPY_MODEL_84b65176d56c429d95671536823ce83b"],"layout":"IPY_MODEL_e29b0cf6db484af98d780f15020a13e4"}},"9ce03ae69aeb4805aa9d8038a88d44ce":{"model_module":"@jupyter-widgets/base","model_module_version":"1.2.0","model_name":"LayoutModel","state":{"_model_module":"@jupyter-widgets/base","_model_module_version":"1.2.0","_model_name":"LayoutModel","_view_count":null,"_view_module":"@jupyter-widgets/base","_view_module_version":"1.2.0","_view_name":"LayoutView","align_content":null,"align_items":null,"align_self":null,"border":null,"bottom":null,"display":null,"flex":null,"flex_flow":null,"grid_area":null,"grid_auto_columns":null,"grid_auto_flow":null,"grid_auto_rows":null,"grid_column":null,"grid_gap":null,"grid_row":null,"grid_template_areas":null,"grid_template_columns":null,"grid_template_rows":null,"height":null,"justify_content":null,"justify_items":null,"left":null,"margin":null,"max_height":null,"max_width":null,"min_height":null,"min_width":null,"object_fit":null,"object_position":null,"order":null,"overflow":null,"overflow_x":null,"overflow_y":null,"padding":null,"right":null,"top":null,"visibility":null,"width":null}},"b07cb209fb6b4b578e53cdcec7eb77f1":{"model_module":"@jupyter-widgets/controls","model_module_version":"1.5.0","model_name":"FloatProgressModel","state":{"_dom_classes":[],"_model_module":"@jupyter-widgets/controls","_model_module_version":"1.5.0","_model_name":"FloatProgressModel","_view_count":null,"_view_module":"@jupyter-widgets/controls","_view_module_version":"1.5.0","_view_name":"ProgressView","bar_style":"success","description":"","description_tooltip":null,"layout":"IPY_MODEL_54bc87031eac41ee8ef1b3ef7911bf26","max":5,"min":0,"orientation":"horizontal","style":"IPY_MODEL_6fe0cda4d6d24703b10536579ed7c090","value":5}},"b65cb4a9d39e40fca5d52bd3323224e9":{"model_module":"@jupyter-widgets/controls","model_module_version":"1.5.0","model_name":"DescriptionStyleModel","state":{"_model_module":"@jupyter-widgets/controls","_model_module_version":"1.5.0","_model_name":"DescriptionStyleModel","_view_count":null,"_view_module":"@jupyter-widgets/base","_view_module_version":"1.2.0","_view_name":"StyleView","description_width":""}},"b66c9fcc8c724ca69c8325cddec30a0f":{"model_module":"@jupyter-widgets/base","model_module_version":"1.2.0","model_name":"LayoutModel","state":{"_model_module":"@jupyter-widgets/base","_model_module_version":"1.2.0","_model_name":"LayoutModel","_view_count":null,"_view_module":"@jupyter-widgets/base","_view_module_version":"1.2.0","_view_name":"LayoutView","align_content":null,"align_items":null,"align_self":null,"border":null,"bottom":null,"display":null,"flex":null,"flex_flow":null,"grid_area":null,"grid_auto_columns":null,"grid_auto_flow":null,"grid_auto_rows":null,"grid_column":null,"grid_gap":null,"grid_row":null,"grid_template_areas":null,"grid_template_columns":null,"grid_template_rows":null,"height":null,"justify_content":null,"justify_items":null,"left":null,"margin":null,"max_height":null,"max_width":null,"min_height":null,"min_width":null,"object_fit":null,"object_position":null,"order":null,"overflow":null,"overflow_x":null,"overflow_y":null,"padding":null,"right":null,"top":null,"visibility":null,"width":null}},"b71e3adbdee74a29b6a09367c8ff2c5b":{"model_module":"@jupyter-widgets/base","model_module_version":"1.2.0","model_name":"LayoutModel","state":{"_model_module":"@jupyter-widgets/base","_model_module_version":"1.2.0","_model_name":"LayoutModel","_view_count":null,"_view_module":"@jupyter-widgets/base","_view_module_version":"1.2.0","_view_name":"LayoutView","align_content":null,"align_items":null,"align_self":null,"border":null,"bottom":null,"display":null,"flex":null,"flex_flow":null,"grid_area":null,"grid_auto_columns":null,"grid_auto_flow":null,"grid_auto_rows":null,"grid_column":null,"grid_gap":null,"grid_row":null,"grid_template_areas":null,"grid_template_columns":null,"grid_template_rows":null,"height":null,"justify_content":null,"justify_items":null,"left":null,"margin":null,"max_height":null,"max_width":null,"min_height":null,"min_width":null,"object_fit":null,"object_position":null,"order":null,"overflow":null,"overflow_x":null,"overflow_y":null,"padding":null,"right":null,"top":null,"visibility":null,"width":null}},"b941729cbd63412f86d11581dccc7c0c":{"model_module":"@jupyter-widgets/base","model_module_version":"1.2.0","model_name":"LayoutModel","state":{"_model_module":"@jupyter-widgets/base","_model_module_version":"1.2.0","_model_name":"LayoutModel","_view_count":null,"_view_module":"@jupyter-widgets/base","_view_module_version":"1.2.0","_view_name":"LayoutView","align_content":null,"align_items":null,"align_self":null,"border":null,"bottom":null,"display":null,"flex":null,"flex_flow":null,"grid_area":null,"grid_auto_columns":null,"grid_auto_flow":null,"grid_auto_rows":null,"grid_column":null,"grid_gap":null,"grid_row":null,"grid_template_areas":null,"grid_template_columns":null,"grid_template_rows":null,"height":null,"justify_content":null,"justify_items":null,"left":null,"margin":null,"max_height":null,"max_width":null,"min_height":null,"min_width":null,"object_fit":null,"object_position":null,"order":null,"overflow":null,"overflow_x":null,"overflow_y":null,"padding":null,"right":null,"top":null,"visibility":null,"width":null}},"bd27f2fe8ba14f1fa59098901e5b023b":{"model_module":"@jupyter-widgets/controls","model_module_version":"1.5.0","model_name":"HBoxModel","state":{"_dom_classes":[],"_model_module":"@jupyter-widgets/controls","_model_module_version":"1.5.0","_model_name":"HBoxModel","_view_count":null,"_view_module":"@jupyter-widgets/controls","_view_module_version":"1.5.0","_view_name":"HBoxView","box_style":"","children":["IPY_MODEL_19cf67d637214b00be27d2dc3ae6dccf","IPY_MODEL_5ff7602c1c6248bba3fdcc26135a4a9f","IPY_MODEL_557dee9dc64b4dfeb2bbcbdb6c842c42"],"layout":"IPY_MODEL_fbbeed6b850c412cb980ffc7588fba61"}},"c99cd71e0bc54d8294ae107dbaa8d364":{"model_module":"@jupyter-widgets/base","model_module_version":"1.2.0","model_name":"LayoutModel","state":{"_model_module":"@jupyter-widgets/base","_model_module_version":"1.2.0","_model_name":"LayoutModel","_view_count":null,"_view_module":"@jupyter-widgets/base","_view_module_version":"1.2.0","_view_name":"LayoutView","align_content":null,"align_items":null,"align_self":null,"border":null,"bottom":null,"display":null,"flex":null,"flex_flow":null,"grid_area":null,"grid_auto_columns":null,"grid_auto_flow":null,"grid_auto_rows":null,"grid_column":null,"grid_gap":null,"grid_row":null,"grid_template_areas":null,"grid_template_columns":null,"grid_template_rows":null,"height":null,"justify_content":null,"justify_items":null,"left":null,"margin":null,"max_height":null,"max_width":null,"min_height":null,"min_width":null,"object_fit":null,"object_position":null,"order":null,"overflow":null,"overflow_x":null,"overflow_y":null,"padding":null,"right":null,"top":null,"visibility":null,"width":null}},"ca2ceb2f40704356bca42d86d1f046b1":{"model_module":"@jupyter-widgets/controls","model_module_version":"1.5.0","model_name":"HBoxModel","state":{"_dom_classes":[],"_model_module":"@jupyter-widgets/controls","_model_module_version":"1.5.0","_model_name":"HBoxModel","_view_count":null,"_view_module":"@jupyter-widgets/controls","_view_module_version":"1.5.0","_view_name":"HBoxView","box_style":"","children":["IPY_MODEL_ff5e7674621349a18901917ea1305752","IPY_MODEL_b07cb209fb6b4b578e53cdcec7eb77f1","IPY_MODEL_799727381e2347bd8a7f7c71e2e00c26"],"layout":"IPY_MODEL_6ccc3614c2be4ea39c56e6c39c89650a"}},"ccafad29dc2048f2872d69b0f5dd3b1c":{"model_module":"@jupyter-widgets/controls","model_module_version":"1.5.0","model_name":"DescriptionStyleModel","state":{"_model_module":"@jupyter-widgets/controls","_model_module_version":"1.5.0","_model_name":"DescriptionStyleModel","_view_count":null,"_view_module":"@jupyter-widgets/base","_view_module_version":"1.2.0","_view_name":"StyleView","description_width":""}},"d502f2c03c544b6b95f7b30d3583eac3":{"model_module":"@jupyter-widgets/base","model_module_version":"1.2.0","model_name":"LayoutModel","state":{"_model_module":"@jupyter-widgets/base","_model_module_version":"1.2.0","_model_name":"LayoutModel","_view_count":null,"_view_module":"@jupyter-widgets/base","_view_module_version":"1.2.0","_view_name":"LayoutView","align_content":null,"align_items":null,"align_self":null,"border":null,"bottom":null,"display":null,"flex":null,"flex_flow":null,"grid_area":null,"grid_auto_columns":null,"grid_auto_flow":null,"grid_auto_rows":null,"grid_column":null,"grid_gap":null,"grid_row":null,"grid_template_areas":null,"grid_template_columns":null,"grid_template_rows":null,"height":null,"justify_content":null,"justify_items":null,"left":null,"margin":null,"max_height":null,"max_width":null,"min_height":null,"min_width":null,"object_fit":null,"object_position":null,"order":null,"overflow":null,"overflow_x":null,"overflow_y":null,"padding":null,"right":null,"top":null,"visibility":null,"width":null}},"da4954ff569442a485788912df7e1b94":{"model_module":"@jupyter-widgets/base","model_module_version":"1.2.0","model_name":"LayoutModel","state":{"_model_module":"@jupyter-widgets/base","_model_module_version":"1.2.0","_model_name":"LayoutModel","_view_count":null,"_view_module":"@jupyter-widgets/base","_view_module_version":"1.2.0","_view_name":"LayoutView","align_content":null,"align_items":null,"align_self":null,"border":null,"bottom":null,"display":null,"flex":null,"flex_flow":null,"grid_area":null,"grid_auto_columns":null,"grid_auto_flow":null,"grid_auto_rows":null,"grid_column":null,"grid_gap":null,"grid_row":null,"grid_template_areas":null,"grid_template_columns":null,"grid_template_rows":null,"height":null,"justify_content":null,"justify_items":null,"left":null,"margin":null,"max_height":null,"max_width":null,"min_height":null,"min_width":null,"object_fit":null,"object_position":null,"order":null,"overflow":null,"overflow_x":null,"overflow_y":null,"padding":null,"right":null,"top":null,"visibility":null,"width":null}},"dc078b1f9a8e4e4c9b767d0f29eb783c":{"model_module":"@jupyter-widgets/base","model_module_version":"1.2.0","model_name":"LayoutModel","state":{"_model_module":"@jupyter-widgets/base","_model_module_version":"1.2.0","_model_name":"LayoutModel","_view_count":null,"_view_module":"@jupyter-widgets/base","_view_module_version":"1.2.0","_view_name":"LayoutView","align_content":null,"align_items":null,"align_self":null,"border":null,"bottom":null,"display":null,"flex":null,"flex_flow":null,"grid_area":null,"grid_auto_columns":null,"grid_auto_flow":null,"grid_auto_rows":null,"grid_column":null,"grid_gap":null,"grid_row":null,"grid_template_areas":null,"grid_template_columns":null,"grid_template_rows":null,"height":null,"justify_content":null,"justify_items":null,"left":null,"margin":null,"max_height":null,"max_width":null,"min_height":null,"min_width":null,"object_fit":null,"object_position":null,"order":null,"overflow":null,"overflow_x":null,"overflow_y":null,"padding":null,"right":null,"top":null,"visibility":null,"width":null}},"ddbf6a7864ce47249f9f278dc2b16b59":{"model_module":"@jupyter-widgets/controls","model_module_version":"1.5.0","model_name":"DescriptionStyleModel","state":{"_model_module":"@jupyter-widgets/controls","_model_module_version":"1.5.0","_model_name":"DescriptionStyleModel","_view_count":null,"_view_module":"@jupyter-widgets/base","_view_module_version":"1.2.0","_view_name":"StyleView","description_width":""}},"df9efe0bd2f344d39fafc4b5da5b5056":{"model_module":"@jupyter-widgets/controls","model_module_version":"1.5.0","model_name":"HTMLModel","state":{"_dom_classes":[],"_model_module":"@jupyter-widgets/controls","_model_module_version":"1.5.0","_model_name":"HTMLModel","_view_count":null,"_view_module":"@jupyter-widgets/controls","_view_module_version":"1.5.0","_view_name":"HTMLView","description":"","description_tooltip":null,"layout":"IPY_MODEL_f16bf4c4ab9941bd9d7193f900123228","placeholder":"​","style":"IPY_MODEL_25b3dc374121442b986faa801c8ce42e","value":"Generate report structure: 100%"}},"e29b0cf6db484af98d780f15020a13e4":{"model_module":"@jupyter-widgets/base","model_module_version":"1.2.0","model_name":"LayoutModel","state":{"_model_module":"@jupyter-widgets/base","_model_module_version":"1.2.0","_model_name":"LayoutModel","_view_count":null,"_view_module":"@jupyter-widgets/base","_view_module_version":"1.2.0","_view_name":"LayoutView","align_content":null,"align_items":null,"align_self":null,"border":null,"bottom":null,"display":null,"flex":null,"flex_flow":null,"grid_area":null,"grid_auto_columns":null,"grid_auto_flow":null,"grid_auto_rows":null,"grid_column":null,"grid_gap":null,"grid_row":null,"grid_template_areas":null,"grid_template_columns":null,"grid_template_rows":null,"height":null,"justify_content":null,"justify_items":null,"left":null,"margin":null,"max_height":null,"max_width":null,"min_height":null,"min_width":null,"object_fit":null,"object_position":null,"order":null,"overflow":null,"overflow_x":null,"overflow_y":null,"padding":null,"right":null,"top":null,"visibility":null,"width":null}},"e39d4eaab323447faf8b59b99026842e":{"model_module":"@jupyter-widgets/controls","model_module_version":"1.5.0","model_name":"DescriptionStyleModel","state":{"_model_module":"@jupyter-widgets/controls","_model_module_version":"1.5.0","_model_name":"DescriptionStyleModel","_view_count":null,"_view_module":"@jupyter-widgets/base","_view_module_version":"1.2.0","_view_name":"StyleView","description_width":""}},"e47eabbc5e6e400a848e843b9ca01a49":{"model_module":"@jupyter-widgets/controls","model_module_version":"1.5.0","model_name":"FloatProgressModel","state":{"_dom_classes":[],"_model_module":"@jupyter-widgets/controls","_model_module_version":"1.5.0","_model_name":"FloatProgressModel","_view_count":null,"_view_module":"@jupyter-widgets/controls","_view_module_version":"1.5.0","_view_name":"ProgressView","bar_style":"success","description":"","description_tooltip":null,"layout":"IPY_MODEL_5e42fa96bf534316baaa4af927900fa5","max":1,"min":0,"orientation":"horizontal","style":"IPY_MODEL_4df048b45d7c4f2f965dbf793911df9f","value":1}},"e5b13baf170d4511ac85cc7368c8221b":{"model_module":"@jupyter-widgets/controls","model_module_version":"1.5.0","model_name":"DescriptionStyleModel","state":{"_model_module":"@jupyter-widgets/controls","_model_module_version":"1.5.0","_model_name":"DescriptionStyleModel","_view_count":null,"_view_module":"@jupyter-widgets/base","_view_module_version":"1.2.0","_view_name":"StyleView","description_width":""}},"e5c164d40ded4d4187d8166466bf110a":{"model_module":"@jupyter-widgets/controls","model_module_version":"1.5.0","model_name":"DescriptionStyleModel","state":{"_model_module":"@jupyter-widgets/controls","_model_module_version":"1.5.0","_model_name":"DescriptionStyleModel","_view_count":null,"_view_module":"@jupyter-widgets/base","_view_module_version":"1.2.0","_view_name":"StyleView","description_width":""}},"ebfffcfaed1e4129875ef3b3e59683c2":{"model_module":"@jupyter-widgets/controls","model_module_version":"1.5.0","model_name":"ProgressStyleModel","state":{"_model_module":"@jupyter-widgets/controls","_model_module_version":"1.5.0","_model_name":"ProgressStyleModel","_view_count":null,"_view_module":"@jupyter-widgets/base","_view_module_version":"1.2.0","_view_name":"StyleView","bar_color":null,"description_width":""}},"f16bf4c4ab9941bd9d7193f900123228":{"model_module":"@jupyter-widgets/base","model_module_version":"1.2.0","model_name":"LayoutModel","state":{"_model_module":"@jupyter-widgets/base","_model_module_version":"1.2.0","_model_name":"LayoutModel","_view_count":null,"_view_module":"@jupyter-widgets/base","_view_module_version":"1.2.0","_view_name":"LayoutView","align_content":null,"align_items":null,"align_self":null,"border":null,"bottom":null,"display":null,"flex":null,"flex_flow":null,"grid_area":null,"grid_auto_columns":null,"grid_auto_flow":null,"grid_auto_rows":null,"grid_column":null,"grid_gap":null,"grid_row":null,"grid_template_areas":null,"grid_template_columns":null,"grid_template_rows":null,"height":null,"justify_content":null,"justify_items":null,"left":null,"margin":null,"max_height":null,"max_width":null,"min_height":null,"min_width":null,"object_fit":null,"object_position":null,"order":null,"overflow":null,"overflow_x":null,"overflow_y":null,"padding":null,"right":null,"top":null,"visibility":null,"width":null}},"f234691cc30a4665a8ba3f21f1509480":{"model_module":"@jupyter-widgets/controls","model_module_version":"1.5.0","model_name":"HTMLModel","state":{"_dom_classes":[],"_model_module":"@jupyter-widgets/controls","_model_module_version":"1.5.0","_model_name":"HTMLModel","_view_count":null,"_view_module":"@jupyter-widgets/controls","_view_module_version":"1.5.0","_view_name":"HTMLView","description":"","description_tooltip":null,"layout":"IPY_MODEL_8fa3c697e1b24507af32cdf0ac6cc0bd","placeholder":"​","style":"IPY_MODEL_ddbf6a7864ce47249f9f278dc2b16b59","value":"Export report to file: 100%"}},"f59fedad89234ed2aab5190fae9ff29d":{"model_module":"@jupyter-widgets/controls","model_module_version":"1.5.0","model_name":"HBoxModel","state":{"_dom_classes":[],"_model_module":"@jupyter-widgets/controls","_model_module_version":"1.5.0","_model_name":"HBoxModel","_view_count":null,"_view_module":"@jupyter-widgets/controls","_view_module_version":"1.5.0","_view_name":"HBoxView","box_style":"","children":["IPY_MODEL_1d733c499e7e4b319950d6a206233c93","IPY_MODEL_6a5affa52cc4492ab8a41a7969439ce5","IPY_MODEL_fbf2b57256f648f39077a96a14476b41"],"layout":"IPY_MODEL_9ce03ae69aeb4805aa9d8038a88d44ce"}},"fbbeed6b850c412cb980ffc7588fba61":{"model_module":"@jupyter-widgets/base","model_module_version":"1.2.0","model_name":"LayoutModel","state":{"_model_module":"@jupyter-widgets/base","_model_module_version":"1.2.0","_model_name":"LayoutModel","_view_count":null,"_view_module":"@jupyter-widgets/base","_view_module_version":"1.2.0","_view_name":"LayoutView","align_content":null,"align_items":null,"align_self":null,"border":null,"bottom":null,"display":null,"flex":null,"flex_flow":null,"grid_area":null,"grid_auto_columns":null,"grid_auto_flow":null,"grid_auto_rows":null,"grid_column":null,"grid_gap":null,"grid_row":null,"grid_template_areas":null,"grid_template_columns":null,"grid_template_rows":null,"height":null,"justify_content":null,"justify_items":null,"left":null,"margin":null,"max_height":null,"max_width":null,"min_height":null,"min_width":null,"object_fit":null,"object_position":null,"order":null,"overflow":null,"overflow_x":null,"overflow_y":null,"padding":null,"right":null,"top":null,"visibility":null,"width":null}},"fbf2b57256f648f39077a96a14476b41":{"model_module":"@jupyter-widgets/controls","model_module_version":"1.5.0","model_name":"HTMLModel","state":{"_dom_classes":[],"_model_module":"@jupyter-widgets/controls","_model_module_version":"1.5.0","_model_name":"HTMLModel","_view_count":null,"_view_module":"@jupyter-widgets/controls","_view_module_version":"1.5.0","_view_name":"HTMLView","description":"","description_tooltip":null,"layout":"IPY_MODEL_fe824db01990429f8390118b5fab6d79","placeholder":"​","style":"IPY_MODEL_952abf85a8804613a72aefae1152ab2b","value":" 10/10 [01:07&lt;00:00,  6.74s/it]"}},"fe824db01990429f8390118b5fab6d79":{"model_module":"@jupyter-widgets/base","model_module_version":"1.2.0","model_name":"LayoutModel","state":{"_model_module":"@jupyter-widgets/base","_model_module_version":"1.2.0","_model_name":"LayoutModel","_view_count":null,"_view_module":"@jupyter-widgets/base","_view_module_version":"1.2.0","_view_name":"LayoutView","align_content":null,"align_items":null,"align_self":null,"border":null,"bottom":null,"display":null,"flex":null,"flex_flow":null,"grid_area":null,"grid_auto_columns":null,"grid_auto_flow":null,"grid_auto_rows":null,"grid_column":null,"grid_gap":null,"grid_row":null,"grid_template_areas":null,"grid_template_columns":null,"grid_template_rows":null,"height":null,"justify_content":null,"justify_items":null,"left":null,"margin":null,"max_height":null,"max_width":null,"min_height":null,"min_width":null,"object_fit":null,"object_position":null,"order":null,"overflow":null,"overflow_x":null,"overflow_y":null,"padding":null,"right":null,"top":null,"visibility":null,"width":null}},"ff5e7674621349a18901917ea1305752":{"model_module":"@jupyter-widgets/controls","model_module_version":"1.5.0","model_name":"HTMLModel","state":{"_dom_classes":[],"_model_module":"@jupyter-widgets/controls","_model_module_version":"1.5.0","_model_name":"HTMLModel","_view_count":null,"_view_module":"@jupyter-widgets/controls","_view_module_version":"1.5.0","_view_name":"HTMLView","description":"","description_tooltip":null,"layout":"IPY_MODEL_d502f2c03c544b6b95f7b30d3583eac3","placeholder":"​","style":"IPY_MODEL_b65cb4a9d39e40fca5d52bd3323224e9","value":"Summarize dataset: 100%"}}},"version_major":2,"version_minor":0}},"kaggle":{"accelerator":"none","dataSources":[],"dockerImageVersionId":30761,"isInternetEnabled":false,"language":"python","sourceType":"notebook","isGpuEnabled":false}},"nbformat_minor":5,"nbformat":4,"cells":[{"cell_type":"markdown","source":"<a class=\"anchor\" id=\"0\"></a>\n# Cryptocurrency : Advanced Analysis & Forecasting","metadata":{"papermill":{"duration":0.140795,"end_time":"2022-06-19T13:08:36.666710","exception":false,"start_time":"2022-06-19T13:08:36.525915","status":"completed"},"tags":[]}},{"cell_type":"markdown","source":"This notebook is devoted to **system analysis and forecasting of the given cryptocurrency** (for example, \"BTC\" = Bitcoin, but it is easy to replace in the variable \"cryptocurrency\"): \n* Exploratory Data Analysis (EDA)\n* Feature Engineering (FE) - synthesis and research of new features (internal and external factors)\n* Data preprocessing and get target\n* Building and tuning of many models of Machine Learning (ML) and choosing the optimal among them \n* Data forecasting \n* Analysis of forecasting accuracy and the importance of features\n\nThis notebook section provides examples of identifying the following **ML models** (but the list goes on):\n* Facebook Prophet \n* ARIMA (and AutoARIMA)\n* Linear Regression\n* KNeighbors Regressor\n* Support Vector Machines\n* Linear SVR\n* Random Forest Regressor\n* Bagging Regressor\n* XGB Regressor\n* MLP Regressor","metadata":{"papermill":{"duration":0.135944,"end_time":"2022-06-19T13:08:36.939568","exception":false,"start_time":"2022-06-19T13:08:36.803624","status":"completed"},"tags":[]}},{"cell_type":"markdown","source":"## Acknowledgements:\n* data download and ML models training from the notebook [Crypto - BTC : 7 prediction models](https://www.kaggle.com/code/vbmokin/crypto-btc-7-prediction-models)\n* FE - from the notebooks: \n    - [BTC Growth Forecasting with Advanced FE for OHLC](https://www.kaggle.com/code/vbmokin/btc-growth-forecasting-with-advanced-fe-for-ohlc)\n    - [G-Research Crypto Forecasting - baseline & FE](https://www.kaggle.com/code/vbmokin/g-research-crypto-forecasting-baseline-fe)\n    - [GResearch Simple LGB Starter](https://www.kaggle.com/code1110/gresearch-simple-lgb-starter)\n    - [COVID in UA: Prophet with 4, Nd seasonality](https://www.kaggle.com/code/vbmokin/crypto-btc-advanced-analysis-forecasting-d)\n    - [COVID-19 in 70 countries: daily Prophet forecast](https://www.kaggle.com/code/vbmokin/covid-19-in-70-countries-daily-prophet-forecast)\n* Stationarity check from the notebook [Time Series: Interpreting ACF and PACF](https://www.kaggle.com/code/iamleonie/time-series-interpreting-acf-and-pacf)\n* [How to Check if Time Series Data is Stationary with Python](https://machinelearningmastery.com/time-series-data-stationary-python/)\n* candle OHLC-chart from the notebook [Cryptocurrency Data Visualization + ARIMA 💰](https://www.kaggle.com/code/fangya/cryptocurrency-data-visualization-arima)\n* about cryptocurrencies - dataset [Forecasting Top Cryptocurrencies](https://www.kaggle.com/datasets/vbmokin/forecasting-top-cryptocurrencies)\n* data about cryptocurrency source via API: https://finance.yahoo.com/cryptocurrencies/\n* data about COVID-19 via API: https://github.com/CSSEGISandData/COVID-19/tree/master/csse_covid_19_data/csse_covid_19_time_series","metadata":{"papermill":{"duration":0.138282,"end_time":"2022-06-19T13:08:37.217588","exception":false,"start_time":"2022-06-19T13:08:37.079306","status":"completed"},"tags":[]}},{"cell_type":"markdown","source":"- The main code of this notebook was written or compiled from many notebooks by **Kaggle Grandmaster, Dr. Eng. Sc., Prof. [Vitalii Mokin](https://www.kaggle.com/vbmokin)**\n\n- The notebook uses material taught to students and graduate students in Ukraine at Vinnytsia National Technical University for **[educational programs of bachelor's, master's and postgraduate programs in specialties 124 System Analysis and 126 Information Systems and Technologies](https://mmss.vntu.edu.ua/index.php/ua/)** (Chair of System Analysis and Information Technologies, Head - Vitalii Mokin).\n\n- This notebook uses material of the textbook **\"Mokin V.B., etc. Technologies of processing and modeling of ecological and economic information. Textbook. 2nd edition. Vinnytsia: VNTU, 2022\"(Ukrainian).**\n\n- Chapters 3. \"EDA\" and 4. \"FE\" of the notebook use material from the scientific paper **\"Mokin V.B., etc.\"Information Technology for the Cryptocurrency Rate Forecasting on the Basics of Complex Feature Engineering\". [Visnyk VPI](https://visnyk.vntu.edu.ua/index.php/visnyk). No 2 (2022).**","metadata":{"papermill":{"duration":0.136989,"end_time":"2022-06-19T13:08:37.491764","exception":false,"start_time":"2022-06-19T13:08:37.354775","status":"completed"},"tags":[]}},{"cell_type":"markdown","source":"A detailed description of the notebook, all ideas, tips on using and adapting to other cryptocurrencies and other tasks of analysis and forecasting of time series (**in Ukrainian**) is available in **VIDEO on the author's YouTube channel in the playlist \"Курс AI-ML-DS Training на Python\": [\"Аналіз та прогнозування часових рядів на прикладі курсу біткоїна\"](https://www.youtube.com/watch?v=hodUvdBC3js&list=PL4DHq-xU-ebUiB6T6vjd0SoDha4GOm8zV&index=23)**","metadata":{"papermill":{"duration":0.139313,"end_time":"2022-06-19T13:08:37.769702","exception":false,"start_time":"2022-06-19T13:08:37.630389","status":"completed"},"tags":[]}},{"cell_type":"markdown","source":"<a class=\"anchor\" id=\"0.1\"></a>\n\n## Table of Contents\n\n1. [Import libraries and set parameters](#1)\n1. [Download data](#2)\n1. [EDA](#3)\n   - [3.1 Market Cap](#3.1)\n   - [3.2 Cryptocurrency data](#3.2)\n   - [3.3 Cryptocurrency features data](#3.3)\n   - [3.4 Stationarity check](#3.4)\n   - [3.5 Identification of seasonality](#3.5)\n   - [3.6 EDA with Pandas Profiling Report](#3.6)   \n1. [FE](#4)\n   - [4.1 FE with TSFRESH](#4.1)\n   - [4.2 FE from technical features (Finance knowledge and Data Science)](#4.2)\n   - [4.3 Analysis of anomalies](#4.3)\n       - [4.3.1 Analysis of anomalies for \"Close\"](#4.3.1)\n       - [4.3.2 Analysis of anomalies for the first data difference \"Close_diff\"](#4.3.2)\n   - [4.4 Analysis of the impact of COVID-19 on the cryptocurrency rate](#4.4)\n   - [4.5 Get target, training, validation and test datasets for ML models](#4.5)\n1. [Model training and forecasting](#5)\n    - [5.1 Facebook Prophet](#5.1)\n    - [5.2 ARIMA](#5.2)\n        - [5.2.1 How to find the order of differencing (d) in ARIMA model](#5.2.1)\n        - [5.2.2 How to find the order of the AR term (p)](#5.2.2)\n        - [5.2.3 How to find the order of the MA term (q)](#5.2.3)\n        - [5.2.4 How to build the ARIMA Model with manually defined parameters](#5.2.4)\n        - [5.2.5 How to build the ARIMA automatically](#5.2.5)\n    - [5.3 Other ML models (Multi-factors models)](#5.3)\n        - [5.3.1 Set parameters for many models](#5.3.1)\n        - [5.3.2 Models training and forecasting](#5.3.2)\n    - [5.4 Choosing the main optimal model and forecasting](#5.4)\n    - [5.5 Feature importance study](#5.5)    ","metadata":{"papermill":{"duration":0.138683,"end_time":"2022-06-19T13:08:38.046415","exception":false,"start_time":"2022-06-19T13:08:37.907732","status":"completed"},"tags":[]}},{"cell_type":"markdown","source":"## 1. Import libraries and set parameters <a class=\"anchor\" id=\"1\"></a>\n\n[Back to Table of Contents](#0.1)","metadata":{"papermill":{"duration":0.137981,"end_time":"2022-06-19T13:08:38.322150","exception":false,"start_time":"2022-06-19T13:08:38.184169","status":"completed"},"tags":[]}},{"cell_type":"code","source":"pip install --upgrade pip","metadata":{"execution":{"iopub.status.busy":"2024-08-27T17:30:36.279550Z","iopub.execute_input":"2024-08-27T17:30:36.280061Z"},"trusted":true},"execution_count":null,"outputs":[{"name":"stdout","text":"Requirement already satisfied: pip in /opt/conda/lib/python3.10/site-packages (24.0)\n\u001b[33mWARNING: Retrying (Retry(total=4, connect=None, read=None, redirect=None, status=None)) after connection broken by 'NewConnectionError('<pip._vendor.urllib3.connection.HTTPSConnection object at 0x7c08a8c2b640>: Failed to establish a new connection: [Errno -3] Temporary failure in name resolution')': /simple/pip/\u001b[0m\u001b[33m\n\u001b[0m\u001b[33mWARNING: Retrying (Retry(total=3, connect=None, read=None, redirect=None, status=None)) after connection broken by 'NewConnectionError('<pip._vendor.urllib3.connection.HTTPSConnection object at 0x7c08a8c2b7f0>: Failed to establish a new connection: [Errno -3] Temporary failure in name resolution')': /simple/pip/\u001b[0m\u001b[33m\n\u001b[0m\u001b[33mWARNING: Retrying (Retry(total=2, connect=None, read=None, redirect=None, status=None)) after connection broken by 'NewConnectionError('<pip._vendor.urllib3.connection.HTTPSConnection object at 0x7c08a8c2baf0>: Failed to establish a new connection: [Errno -3] Temporary failure in name resolution')': /simple/pip/\u001b[0m\u001b[33m\n\u001b[0m\u001b[33mWARNING: Retrying (Retry(total=1, connect=None, read=None, redirect=None, status=None)) after connection broken by 'NewConnectionError('<pip._vendor.urllib3.connection.HTTPSConnection object at 0x7c08a8c2bca0>: Failed to establish a new connection: [Errno -3] Temporary failure in name resolution')': /simple/pip/\u001b[0m\u001b[33m\n\u001b[0m\u001b[33mWARNING: Retrying (Retry(total=0, connect=None, read=None, redirect=None, status=None)) after connection broken by 'NewConnectionError('<pip._vendor.urllib3.connection.HTTPSConnection object at 0x7c08a8c2be50>: Failed to establish a new connection: [Errno -3] Temporary failure in name resolution')': /simple/pip/\u001b[0m\u001b[33m\n\u001b[0m","output_type":"stream"}]},{"cell_type":"code","source":"# Import libraries\nimport random\nimport os\nimport numpy as np \nimport pandas as pd \nimport requests\nimport pandas_datareader as web\n\n# Date\nimport datetime as dt\nfrom datetime import date, timedelta, datetime\n\n# EDA\nimport matplotlib.pyplot as plt\nfrom matplotlib.pylab import rcParams\nimport plotly.express as px\nimport plotly.graph_objects as go\nfrom plotly.offline import init_notebook_mode\ninit_notebook_mode(connected=True)\nimport ydata_profiling as pp\n\n# FE\nfrom tsfresh import extract_features, select_features, extract_relevant_features\nfrom tsfresh.utilities.dataframe_functions import impute\nfrom sklearn.inspection import permutation_importance\nimport eli5\nfrom eli5.sklearn import PermutationImportance\nimport shap\n\n# Time Series - EDA and Modelling\nimport statsmodels.api as sm\nfrom statsmodels.graphics.tsaplots import plot_acf, plot_pacf\nfrom statsmodels.tsa.stattools import adfuller\nfrom statsmodels.tsa.seasonal import seasonal_decompose\nfrom statsmodels.tsa.arima_model import ARIMA\n\n# Metrics\nfrom sklearn.metrics import r2_score\nfrom sklearn.metrics import mean_squared_error, mean_absolute_percentage_error\n\n# Modeling and preprocessing\nfrom sklearn.preprocessing import StandardScaler, MinMaxScaler\nfrom sklearn.model_selection import train_test_split, GridSearchCV\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.svm import SVR, LinearSVR\nfrom sklearn.neighbors import KNeighborsRegressor\nfrom sklearn.ensemble import RandomForestRegressor\nfrom sklearn.ensemble import BaggingRegressor, AdaBoostRegressor\nfrom sklearn.neural_network import MLPRegressor\nfrom prophet import Prophet\nimport xgboost as xgb\nfrom xgboost import XGBRegressor\nimport lightgbm as lgb\nfrom lightgbm import LGBMRegressor\n\nimport warnings\nwarnings.filterwarnings(\"ignore\")","metadata":{"papermill":{"duration":12.419096,"end_time":"2022-06-19T13:08:50.882361","exception":false,"start_time":"2022-06-19T13:08:38.463265","status":"completed"},"tags":[],"execution":{"iopub.status.busy":"2024-08-27T17:24:14.701643Z","iopub.status.idle":"2024-08-27T17:24:14.702278Z","shell.execute_reply.started":"2024-08-27T17:24:14.701849Z","shell.execute_reply":"2024-08-27T17:24:14.701870Z"},"trusted":true},"execution_count":null,"outputs":[]},{"cell_type":"code","source":"# What EDA & FE techniques use?\nis_EDA_with_Pandas_Profiling = True # or False - Get Pandas Profiling Report or no?\nis_EDA_with_COVID19_data = True # or False - Make EDA with COVID-19 data or no?\nis_anomalies = True # or False - Take into account anomalies or no?","metadata":{"papermill":{"duration":0.146646,"end_time":"2022-06-19T13:08:51.168417","exception":false,"start_time":"2022-06-19T13:08:51.021771","status":"completed"},"tags":[],"execution":{"iopub.status.busy":"2024-08-27T17:21:43.783043Z","iopub.execute_input":"2024-08-27T17:21:43.784006Z","iopub.status.idle":"2024-08-27T17:21:43.789782Z","shell.execute_reply.started":"2024-08-27T17:21:43.783959Z","shell.execute_reply":"2024-08-27T17:21:43.788573Z"},"trusted":true},"execution_count":2,"outputs":[]},{"cell_type":"code","source":"# What type of model to use?\nis_Prophet = True   # or False - Facebook Prophet\nis_ARIMA = True     # or False - ARIMA and AutoARIMA\nis_other_ML = True  # or False - multi-factors models: trees, neural networks, etc.","metadata":{"papermill":{"duration":0.148125,"end_time":"2022-06-19T13:08:51.455582","exception":false,"start_time":"2022-06-19T13:08:51.307457","status":"completed"},"tags":[],"execution":{"iopub.status.busy":"2024-08-27T17:21:43.791319Z","iopub.execute_input":"2024-08-27T17:21:43.793508Z","iopub.status.idle":"2024-08-27T17:21:43.815406Z","shell.execute_reply.started":"2024-08-27T17:21:43.793361Z","shell.execute_reply":"2024-08-27T17:21:43.814192Z"},"trusted":true},"execution_count":3,"outputs":[]},{"cell_type":"code","source":"!pip install pmdarima","metadata":{"execution":{"iopub.status.busy":"2024-08-27T17:25:29.354722Z","iopub.execute_input":"2024-08-27T17:25:29.355351Z","iopub.status.idle":"2024-08-27T17:27:59.344959Z","shell.execute_reply.started":"2024-08-27T17:25:29.355290Z","shell.execute_reply":"2024-08-27T17:27:59.343381Z"},"trusted":true},"execution_count":5,"outputs":[{"name":"stdout","text":"\u001b[33mWARNING: Retrying (Retry(total=4, connect=None, read=None, redirect=None, status=None)) after connection broken by 'NewConnectionError('<pip._vendor.urllib3.connection.HTTPSConnection object at 0x7f85e6d63580>: Failed to establish a new connection: [Errno -3] Temporary failure in name resolution')': /simple/pmdarima/\u001b[0m\u001b[33m\n\u001b[0m\u001b[33mWARNING: Retrying (Retry(total=3, connect=None, read=None, redirect=None, status=None)) after connection broken by 'NewConnectionError('<pip._vendor.urllib3.connection.HTTPSConnection object at 0x7f85e6d63880>: Failed to establish a new connection: [Errno -3] Temporary failure in name resolution')': /simple/pmdarima/\u001b[0m\u001b[33m\n\u001b[0m\u001b[33mWARNING: Retrying (Retry(total=2, connect=None, read=None, redirect=None, status=None)) after connection broken by 'NewConnectionError('<pip._vendor.urllib3.connection.HTTPSConnection object at 0x7f85e6d63b20>: Failed to establish a new connection: [Errno -3] Temporary failure in name resolution')': /simple/pmdarima/\u001b[0m\u001b[33m\n\u001b[0m\u001b[33mWARNING: Retrying (Retry(total=1, connect=None, read=None, redirect=None, status=None)) after connection broken by 'NewConnectionError('<pip._vendor.urllib3.connection.HTTPSConnection object at 0x7f85e6d63cd0>: Failed to establish a new connection: [Errno -3] Temporary failure in name resolution')': /simple/pmdarima/\u001b[0m\u001b[33m\n\u001b[0m\u001b[33mWARNING: Retrying (Retry(total=0, connect=None, read=None, redirect=None, status=None)) after connection broken by 'NewConnectionError('<pip._vendor.urllib3.connection.HTTPSConnection object at 0x7f85e6d63eb0>: Failed to establish a new connection: [Errno -3] Temporary failure in name resolution')': /simple/pmdarima/\u001b[0m\u001b[33m\n\u001b[0m\u001b[31mERROR: Could not find a version that satisfies the requirement pmdarima (from versions: none)\u001b[0m\u001b[31m\n\u001b[0m\u001b[31mERROR: No matching distribution found for pmdarima\u001b[0m\u001b[31m\n\u001b[0m","output_type":"stream"}]},{"cell_type":"code","source":"# Automatic building ARIMA for Time Series\nif is_ARIMA:\n    \n    import pmdarima as pm","metadata":{"_kg_hide-output":true,"papermill":{"duration":13.26948,"end_time":"2022-06-19T13:09:04.863222","exception":false,"start_time":"2022-06-19T13:08:51.593742","status":"completed"},"tags":[],"execution":{"iopub.status.busy":"2024-08-27T17:21:43.818362Z","iopub.execute_input":"2024-08-27T17:21:43.819218Z","iopub.status.idle":"2024-08-27T17:24:14.474343Z","shell.execute_reply.started":"2024-08-27T17:21:43.819174Z","shell.execute_reply":"2024-08-27T17:24:14.464011Z"},"trusted":true},"execution_count":4,"outputs":[{"name":"stdout","text":"\u001b[33mWARNING: Retrying (Retry(total=4, connect=None, read=None, redirect=None, status=None)) after connection broken by 'NewConnectionError('<pip._vendor.urllib3.connection.HTTPSConnection object at 0x7c7035d6f670>: Failed to establish a new connection: [Errno -3] Temporary failure in name resolution')': /simple/pmdarima/\u001b[0m\u001b[33m\n\u001b[0m\u001b[33mWARNING: Retrying (Retry(total=3, connect=None, read=None, redirect=None, status=None)) after connection broken by 'NewConnectionError('<pip._vendor.urllib3.connection.HTTPSConnection object at 0x7c7035d6f970>: Failed to establish a new connection: [Errno -3] Temporary failure in name resolution')': /simple/pmdarima/\u001b[0m\u001b[33m\n\u001b[0m\u001b[33mWARNING: Retrying (Retry(total=2, connect=None, read=None, redirect=None, status=None)) after connection broken by 'NewConnectionError('<pip._vendor.urllib3.connection.HTTPSConnection object at 0x7c7035d6fc10>: Failed to establish a new connection: [Errno -3] Temporary failure in name resolution')': /simple/pmdarima/\u001b[0m\u001b[33m\n\u001b[0m\u001b[33mWARNING: Retrying (Retry(total=1, connect=None, read=None, redirect=None, status=None)) after connection broken by 'NewConnectionError('<pip._vendor.urllib3.connection.HTTPSConnection object at 0x7c7035d6fdc0>: Failed to establish a new connection: [Errno -3] Temporary failure in name resolution')': /simple/pmdarima/\u001b[0m\u001b[33m\n\u001b[0m\u001b[33mWARNING: Retrying (Retry(total=0, connect=None, read=None, redirect=None, status=None)) after connection broken by 'NewConnectionError('<pip._vendor.urllib3.connection.HTTPSConnection object at 0x7c7035d6ffa0>: Failed to establish a new connection: [Errno -3] Temporary failure in name resolution')': /simple/pmdarima/\u001b[0m\u001b[33m\n\u001b[0m\u001b[31mERROR: Could not find a version that satisfies the requirement pmdarima (from versions: none)\u001b[0m\u001b[31m\n\u001b[0m\u001b[31mERROR: No matching distribution found for pmdarima\u001b[0m\u001b[31m\n\u001b[0m","output_type":"stream"},{"traceback":["\u001b[0;31m---------------------------------------------------------------------------\u001b[0m","\u001b[0;31mModuleNotFoundError\u001b[0m                       Traceback (most recent call last)","Cell \u001b[0;32mIn[4], line 4\u001b[0m\n\u001b[1;32m      2\u001b[0m \u001b[38;5;28;01mif\u001b[39;00m is_ARIMA:\n\u001b[1;32m      3\u001b[0m     get_ipython()\u001b[38;5;241m.\u001b[39msystem(\u001b[38;5;124m'\u001b[39m\u001b[38;5;124mpip install pmdarima\u001b[39m\u001b[38;5;124m'\u001b[39m)\n\u001b[0;32m----> 4\u001b[0m     \u001b[38;5;28;01mimport\u001b[39;00m \u001b[38;5;21;01mpmdarima\u001b[39;00m \u001b[38;5;28;01mas\u001b[39;00m \u001b[38;5;21;01mpm\u001b[39;00m\n","\u001b[0;31mModuleNotFoundError\u001b[0m: No module named 'pmdarima'"],"ename":"ModuleNotFoundError","evalue":"No module named 'pmdarima'","output_type":"error"}]},{"cell_type":"code","source":"# Set random state\ndef fix_all_seeds(seed):\n    np.random.seed(seed)\n    random.seed(seed)\n    os.environ['PYTHONHASHSEED'] = str(seed)\n\nrandom_state = 42\nfix_all_seeds(random_state)","metadata":{"papermill":{"duration":0.152186,"end_time":"2022-06-19T13:09:05.158460","exception":false,"start_time":"2022-06-19T13:09:05.006274","status":"completed"},"tags":[],"execution":{"iopub.status.busy":"2024-08-27T17:24:14.476257Z","iopub.status.idle":"2024-08-27T17:24:14.476792Z","shell.execute_reply.started":"2024-08-27T17:24:14.476535Z","shell.execute_reply":"2024-08-27T17:24:14.476562Z"},"trusted":true},"execution_count":null,"outputs":[]},{"cell_type":"markdown","source":"**TASK:** It is proposed to experiment with forecasting_days","metadata":{"papermill":{"duration":0.142768,"end_time":"2022-06-19T13:09:05.445476","exception":false,"start_time":"2022-06-19T13:09:05.302708","status":"completed"},"tags":[]}},{"cell_type":"code","source":"# Set main parameters\ncryptocurrency = 'BTC'\ntarget = 'Close'\nforecasting_days = 10  # forecasting_days > 1","metadata":{"papermill":{"duration":0.149287,"end_time":"2022-06-19T13:09:05.737206","exception":false,"start_time":"2022-06-19T13:09:05.587919","status":"completed"},"tags":[],"execution":{"iopub.status.busy":"2024-08-27T17:24:14.477988Z","iopub.status.idle":"2024-08-27T17:24:14.478493Z","shell.execute_reply.started":"2024-08-27T17:24:14.478259Z","shell.execute_reply":"2024-08-27T17:24:14.478283Z"},"trusted":true},"execution_count":null,"outputs":[]},{"cell_type":"markdown","source":"**TASK :** It is proposed to experiment with date_start and date_end","metadata":{"papermill":{"duration":0.146771,"end_time":"2022-06-19T13:09:06.030599","exception":false,"start_time":"2022-06-19T13:09:05.883828","status":"completed"},"tags":[]}},{"cell_type":"code","source":"# Set time interval of data for given cryptocurrency - the period of coronavirus in 2020-2021\ndate_start = dt.datetime(2020, 4, 1)\n# date_end = dt.datetime.now()\ndate_end = dt.datetime(2021, 12, 31)\nprint(f\"Time interval: from {date_start} to {date_end}\")","metadata":{"papermill":{"duration":0.154798,"end_time":"2022-06-19T13:09:06.329750","exception":false,"start_time":"2022-06-19T13:09:06.174952","status":"completed"},"tags":[],"execution":{"iopub.status.busy":"2024-08-27T17:24:14.480533Z","iopub.status.idle":"2024-08-27T17:24:14.480981Z","shell.execute_reply.started":"2024-08-27T17:24:14.480756Z","shell.execute_reply":"2024-08-27T17:24:14.480777Z"},"trusted":true},"execution_count":null,"outputs":[]},{"cell_type":"markdown","source":"## 2. Download data <a class=\"anchor\" id=\"2\"></a>\n\n[Back to Table of Contents](#0.1)","metadata":{"papermill":{"duration":0.143947,"end_time":"2022-06-19T13:09:06.618644","exception":false,"start_time":"2022-06-19T13:09:06.474697","status":"completed"},"tags":[]}},{"cell_type":"code","source":"# Download information about cryptocurrencies\ndf_about = pd.read_csv(\"../input/forecasting-top-cryptocurrencies/about_top_cryptocurrencies_1B_information.csv\", sep=\";\")\ndisplay(df_about)","metadata":{"papermill":{"duration":0.21081,"end_time":"2022-06-19T13:09:06.973040","exception":false,"start_time":"2022-06-19T13:09:06.762230","status":"completed"},"tags":[],"execution":{"iopub.status.busy":"2024-08-27T17:24:14.482233Z","iopub.status.idle":"2024-08-27T17:24:14.482684Z","shell.execute_reply.started":"2024-08-27T17:24:14.482448Z","shell.execute_reply":"2024-08-27T17:24:14.482471Z"},"trusted":true},"execution_count":null,"outputs":[]},{"cell_type":"code","source":"def get_part_number(x):\n    # Get 1 - st, 2 - nd, 3 - rd, 4.. - th in the first, second, third, ...\n    if x==1:\n        return 'st'\n    elif x==2:\n        return 'nd'\n    elif x==3:\n        return 'rd'\n    else: return 'th'","metadata":{"papermill":{"duration":0.153252,"end_time":"2022-06-19T13:09:07.271552","exception":false,"start_time":"2022-06-19T13:09:07.118300","status":"completed"},"tags":[],"execution":{"iopub.status.busy":"2024-08-27T17:24:14.484509Z","iopub.status.idle":"2024-08-27T17:24:14.484938Z","shell.execute_reply.started":"2024-08-27T17:24:14.484718Z","shell.execute_reply":"2024-08-27T17:24:14.484738Z"},"trusted":true},"execution_count":null,"outputs":[]},{"cell_type":"code","source":"def get_rank_cryptocurrency(cryptocurrency):\n    # Get rank by Market Cap for code of the cryptocurrency\n    # Download the dataset from https://www.kaggle.com/datasets/vbmokin/forecasting-top-cryptocurrencies\n    \n    place = df_about.index[df_about['code'] == cryptocurrency].tolist()[0]\n    print(f\"{df_about.loc[place, 'name']} was {place+1}{get_part_number(place+1)}\",\n          \"among the world's cryptocurrencies by market capitalization (2022-04-11)\")\n    \n# Get rank by Market Cap of the cryptocurrency\nget_rank_cryptocurrency(cryptocurrency)","metadata":{"papermill":{"duration":0.159906,"end_time":"2022-06-19T13:09:07.576781","exception":false,"start_time":"2022-06-19T13:09:07.416875","status":"completed"},"tags":[],"execution":{"iopub.status.busy":"2024-08-27T17:24:14.486501Z","iopub.status.idle":"2024-08-27T17:24:14.486911Z","shell.execute_reply.started":"2024-08-27T17:24:14.486708Z","shell.execute_reply":"2024-08-27T17:24:14.486729Z"},"trusted":true},"execution_count":null,"outputs":[]},{"cell_type":"code","source":"def get_data(cryptocurrency, date_start, date_end=None):\n    # Get data for given cryptocurrency in USD from Yahoo.finance and https://coinmarketcap.com/\n    # date_end = None means that the date_end is the current day\n    \n    if date_end is None:\n        date_end = dt.datetime.now()\n    df = web.DataReader(f'{cryptocurrency}-USD', 'yahoo', date_start, date_end)\n    \n    return df\n\n# Download data of the cryptocurrency via API\ndf = get_data(cryptocurrency, date_start, date_end)\ndf","metadata":{"papermill":{"duration":1.478117,"end_time":"2022-06-19T13:09:09.199140","exception":false,"start_time":"2022-06-19T13:09:07.721023","status":"completed"},"tags":[],"execution":{"iopub.status.busy":"2024-08-27T17:24:14.489482Z","iopub.status.idle":"2024-08-27T17:24:14.490076Z","shell.execute_reply.started":"2024-08-27T17:24:14.489768Z","shell.execute_reply":"2024-08-27T17:24:14.489798Z"},"trusted":true},"execution_count":null,"outputs":[]},{"cell_type":"code","source":"# Correlation coefficients\ndf.corr()","metadata":{"papermill":{"duration":0.176043,"end_time":"2022-06-19T13:09:09.532263","exception":false,"start_time":"2022-06-19T13:09:09.356220","status":"completed"},"tags":[],"execution":{"iopub.status.busy":"2024-08-27T17:24:14.492057Z","iopub.status.idle":"2024-08-27T17:24:14.492674Z","shell.execute_reply.started":"2024-08-27T17:24:14.492371Z","shell.execute_reply":"2024-08-27T17:24:14.492404Z"},"trusted":true},"execution_count":null,"outputs":[]},{"cell_type":"code","source":"# Correlation coefficients\ndf.corr()['Close']","metadata":{"papermill":{"duration":0.172806,"end_time":"2022-06-19T13:09:09.859502","exception":false,"start_time":"2022-06-19T13:09:09.686696","status":"completed"},"tags":[],"execution":{"iopub.status.busy":"2024-08-27T17:24:14.494758Z","iopub.status.idle":"2024-08-27T17:24:14.495383Z","shell.execute_reply.started":"2024-08-27T17:24:14.495037Z","shell.execute_reply":"2024-08-27T17:24:14.495066Z"},"trusted":true},"execution_count":null,"outputs":[]},{"cell_type":"code","source":"df = df.drop(columns = [\"Adj Close\"])\ndf","metadata":{"papermill":{"duration":0.174573,"end_time":"2022-06-19T13:09:10.187952","exception":false,"start_time":"2022-06-19T13:09:10.013379","status":"completed"},"tags":[],"execution":{"iopub.status.busy":"2024-08-27T17:24:14.496677Z","iopub.status.idle":"2024-08-27T17:24:14.497273Z","shell.execute_reply.started":"2024-08-27T17:24:14.496944Z","shell.execute_reply":"2024-08-27T17:24:14.496974Z"},"trusted":true},"execution_count":null,"outputs":[]},{"cell_type":"markdown","source":"## 3. EDA <a class=\"anchor\" id=\"3\"></a>\n\n[Back to Table of Contents](#0.1)","metadata":{"papermill":{"duration":0.154225,"end_time":"2022-06-19T13:09:10.491857","exception":false,"start_time":"2022-06-19T13:09:10.337632","status":"completed"},"tags":[]}},{"cell_type":"markdown","source":"### 3.1. Market Cap <a class=\"anchor\" id=\"3.1\"></a>\n\n[Back to Table of Contents](#0.1)","metadata":{"papermill":{"duration":0.158211,"end_time":"2022-06-19T13:09:10.803595","exception":false,"start_time":"2022-06-19T13:09:10.645384","status":"completed"},"tags":[]}},{"cell_type":"code","source":"# Market Cap\ncrypto = pd.Series(df_about.market_cap.head(20).tolist(), index=df_about.name.head(20).tolist(), name=\"Капіталізація ринка\")\ncrypto.plot.pie(figsize=(10, 10))","metadata":{"papermill":{"duration":0.22007,"end_time":"2022-06-19T13:09:11.178506","exception":false,"start_time":"2022-06-19T13:09:10.958436","status":"completed"},"tags":[],"execution":{"iopub.status.busy":"2024-08-27T17:24:14.499750Z","iopub.status.idle":"2024-08-27T17:24:14.500385Z","shell.execute_reply.started":"2024-08-27T17:24:14.500040Z","shell.execute_reply":"2024-08-27T17:24:14.500072Z"},"trusted":true},"execution_count":null,"outputs":[]},{"cell_type":"markdown","source":"### 3.2. Cryptocurrency data <a class=\"anchor\" id=\"3.2\"></a>\n\n[Back to Table of Contents](#0.1)","metadata":{"papermill":{"duration":0.153081,"end_time":"2022-06-19T13:09:11.484827","exception":false,"start_time":"2022-06-19T13:09:11.331746","status":"completed"},"tags":[]}},{"cell_type":"code","source":"df['Close'].plot(grid=True, figsize=(12,8))","metadata":{"papermill":{"duration":0.199821,"end_time":"2022-06-19T13:09:11.839811","exception":false,"start_time":"2022-06-19T13:09:11.639990","status":"completed"},"tags":[],"execution":{"iopub.status.busy":"2024-08-27T17:24:14.501558Z","iopub.status.idle":"2024-08-27T17:24:14.502171Z","shell.execute_reply.started":"2024-08-27T17:24:14.501840Z","shell.execute_reply":"2024-08-27T17:24:14.501870Z"},"trusted":true},"execution_count":null,"outputs":[]},{"cell_type":"markdown","source":"### 3.3. Cryptocurrency features data <a class=\"anchor\" id=\"3.3\"></a>\n\n[Back to Table of Contents](#0.1)","metadata":{"papermill":{"duration":0.148868,"end_time":"2022-06-19T13:09:12.138180","exception":false,"start_time":"2022-06-19T13:09:11.989312","status":"completed"},"tags":[]}},{"cell_type":"code","source":"display(df)","metadata":{"papermill":{"duration":0.166457,"end_time":"2022-06-19T13:09:12.452917","exception":false,"start_time":"2022-06-19T13:09:12.286460","status":"completed"},"tags":[],"execution":{"iopub.status.busy":"2024-08-27T17:24:14.504969Z","iopub.status.idle":"2024-08-27T17:24:14.505454Z","shell.execute_reply.started":"2024-08-27T17:24:14.505230Z","shell.execute_reply":"2024-08-27T17:24:14.505253Z"},"trusted":true},"execution_count":null,"outputs":[]},{"cell_type":"code","source":"def c_chart(data,label):\n    # Thanks to https://www.kaggle.com/code/fangya/cryptocurrency-data-visualization-arima\n    candlestick = go.Figure(data = [go.Candlestick(x=data.index,\n                                                   open = data['Open'], \n                                                   high = data['High'], \n                                                   low = data['Low'], \n                                                   close = data['Close'])])\n    candlestick.update_xaxes(title_text = 'Time',\n                             rangeslider_visible = True)\n\n    candlestick.update_layout(\n    title = {\n            'text': '{:} Candelstick Chart'.format(label),\n            \"y\":0.8,\n            \"x\":0.5,\n            'xanchor': 'center',\n            'yanchor': 'top'})\n\n    candlestick.update_yaxes(title_text = 'Price in USD', ticksuffix = '$')\n    return candlestick","metadata":{"papermill":{"duration":0.157989,"end_time":"2022-06-19T13:09:12.759209","exception":false,"start_time":"2022-06-19T13:09:12.601220","status":"completed"},"tags":[],"execution":{"iopub.status.busy":"2024-08-27T17:24:14.506654Z","iopub.status.idle":"2024-08-27T17:24:14.507179Z","shell.execute_reply.started":"2024-08-27T17:24:14.506921Z","shell.execute_reply":"2024-08-27T17:24:14.506944Z"},"trusted":true},"execution_count":null,"outputs":[]},{"cell_type":"code","source":"%matplotlib inline\nbtc_candle=c_chart(df, label=\"BTC Price\")\nbtc_candle.show()","metadata":{"papermill":{"duration":0.298614,"end_time":"2022-06-19T13:09:13.208473","exception":false,"start_time":"2022-06-19T13:09:12.909859","status":"completed"},"tags":[],"execution":{"iopub.status.busy":"2024-08-27T17:24:14.509346Z","iopub.status.idle":"2024-08-27T17:24:14.509783Z","shell.execute_reply.started":"2024-08-27T17:24:14.509559Z","shell.execute_reply":"2024-08-27T17:24:14.509580Z"},"trusted":true},"execution_count":null,"outputs":[]},{"cell_type":"markdown","source":"### 3.4. Stationarity check <a class=\"anchor\" id=\"3.4\"></a>\n\n[Back to Table of Contents](#0.1)\n\nThanks to [Time Series: Interpreting ACF and PACF](https://www.kaggle.com/code/iamleonie/time-series-interpreting-acf-and-pacf)","metadata":{"papermill":{"duration":0.164206,"end_time":"2022-06-19T13:09:13.542826","exception":false,"start_time":"2022-06-19T13:09:13.378620","status":"completed"},"tags":[]}},{"cell_type":"markdown","source":"ACF and PACF assume stationarity of the underlying time series.\nStaionarity can be checked by performing an **Augmented Dickey-Fuller (ADF) test**:\n\n> - p-value > 0.05: Fail to reject the null hypothesis (H0), the data has a unit root and is non-stationary.\n> - p-value <= 0.05: Reject the null hypothesis (H0), the data does not have a unit root and is stationary.\n>\n> [...] We can see that our [ADF] statistic value [...] is less than the value [...] at 1%.\nThis suggests that we can reject the null hypothesis with a significance level of less than 1% (i.e. a low probability that the result is a statistical fluke).\nRejecting the null hypothesis means that the process has no unit root, and in turn that the time series is stationary or does not have time-dependent structure. - [Machine Learning Mastery: How to Check if Time Series Data is Stationary with Python](https://machinelearningmastery.com/time-series-data-stationary-python/)\n\nIf the time series is stationary, continue to the next steps.\n**If the time series is not stationary, try differencing the time series** and check its stationarity again.\n","metadata":{"papermill":{"duration":0.168445,"end_time":"2022-06-19T13:09:13.878009","exception":false,"start_time":"2022-06-19T13:09:13.709564","status":"completed"},"tags":[]}},{"cell_type":"code","source":"def check_stationarity(series):\n    # Thanks to https://machinelearningmastery.com/time-series-data-stationary-python/\n\n    result = adfuller(series.values)\n\n    print('ADF Statistic: %f' % result[0])\n    print('p-value: %f' % result[1])\n    print('Critical Values:')\n    for key, value in result[4].items():\n        print('\\t%s: %.3f' % (key, value))\n\n    if (result[1] <= 0.05) & (result[4]['5%'] > result[0]):\n        print(\"\\u001b[32mStationary\\u001b[0m\")\n    else:\n        print(\"\\x1b[31mNon-stationary\\x1b[0m\")","metadata":{"papermill":{"duration":0.175998,"end_time":"2022-06-19T13:09:14.221967","exception":false,"start_time":"2022-06-19T13:09:14.045969","status":"completed"},"tags":[],"execution":{"iopub.status.busy":"2024-08-27T17:24:14.511551Z","iopub.status.idle":"2024-08-27T17:24:14.512153Z","shell.execute_reply.started":"2024-08-27T17:24:14.511831Z","shell.execute_reply":"2024-08-27T17:24:14.511861Z"},"trusted":true},"execution_count":null,"outputs":[]},{"cell_type":"code","source":"# Stationarity check\ncheck_stationarity(df['Close'])","metadata":{"papermill":{"duration":0.2221,"end_time":"2022-06-19T13:09:14.617824","exception":false,"start_time":"2022-06-19T13:09:14.395724","status":"completed"},"tags":[],"execution":{"iopub.status.busy":"2024-08-27T17:24:14.514636Z","iopub.status.idle":"2024-08-27T17:24:14.515264Z","shell.execute_reply.started":"2024-08-27T17:24:14.514923Z","shell.execute_reply":"2024-08-27T17:24:14.514953Z"},"trusted":true},"execution_count":null,"outputs":[]},{"cell_type":"code","source":"# Stationarity check of the first difference of time series\ncheck_stationarity(df['Close'].diff().dropna())","metadata":{"papermill":{"duration":0.218007,"end_time":"2022-06-19T13:09:15.053361","exception":false,"start_time":"2022-06-19T13:09:14.835354","status":"completed"},"tags":[],"execution":{"iopub.status.busy":"2024-08-27T17:24:14.516510Z","iopub.status.idle":"2024-08-27T17:24:14.517072Z","shell.execute_reply.started":"2024-08-27T17:24:14.516779Z","shell.execute_reply":"2024-08-27T17:24:14.516810Z"},"trusted":true},"execution_count":null,"outputs":[]},{"cell_type":"code","source":"# Stationarity check of the second difference of time series\ncheck_stationarity(df['Close'].diff().diff().dropna())","metadata":{"papermill":{"duration":0.210849,"end_time":"2022-06-19T13:09:15.483123","exception":false,"start_time":"2022-06-19T13:09:15.272274","status":"completed"},"tags":[],"execution":{"iopub.status.busy":"2024-08-27T17:24:14.518984Z","iopub.status.idle":"2024-08-27T17:24:14.519482Z","shell.execute_reply.started":"2024-08-27T17:24:14.519245Z","shell.execute_reply":"2024-08-27T17:24:14.519268Z"},"trusted":true},"execution_count":null,"outputs":[]},{"cell_type":"markdown","source":"Therefore, it is necessary to model the first difference of the series:","metadata":{"execution":{"iopub.execute_input":"2022-05-19T06:54:31.590261Z","iopub.status.busy":"2022-05-19T06:54:31.589933Z","iopub.status.idle":"2022-05-19T06:54:31.596124Z","shell.execute_reply":"2022-05-19T06:54:31.594909Z","shell.execute_reply.started":"2022-05-19T06:54:31.590231Z"},"papermill":{"duration":0.167976,"end_time":"2022-06-19T13:09:15.872436","exception":false,"start_time":"2022-06-19T13:09:15.704460","status":"completed"},"tags":[]}},{"cell_type":"code","source":"df['Close_diff'] = df['Close'].diff()\ndf = df.dropna()\ndf","metadata":{"papermill":{"duration":0.19293,"end_time":"2022-06-19T13:09:16.233539","exception":false,"start_time":"2022-06-19T13:09:16.040609","status":"completed"},"tags":[],"execution":{"iopub.status.busy":"2024-08-27T17:24:14.520789Z","iopub.status.idle":"2024-08-27T17:24:14.521255Z","shell.execute_reply.started":"2024-08-27T17:24:14.521003Z","shell.execute_reply":"2024-08-27T17:24:14.521025Z"},"trusted":true},"execution_count":null,"outputs":[]},{"cell_type":"markdown","source":"### 3.5. Identification of seasonality <a class=\"anchor\" id=\"3.5\"></a>\n\n[Back to Table of Contents](#0.1)","metadata":{"papermill":{"duration":0.166825,"end_time":"2022-06-19T13:09:16.569515","exception":false,"start_time":"2022-06-19T13:09:16.402690","status":"completed"},"tags":[]}},{"cell_type":"code","source":"# Get seasonality of the time series\ndecomp = seasonal_decompose(df.Close)\nfig = decomp.plot()\nfig.set_size_inches((12, 10))\nfig.tight_layout()\nplt.show()","metadata":{"papermill":{"duration":1.188686,"end_time":"2022-06-19T13:09:17.925628","exception":false,"start_time":"2022-06-19T13:09:16.736942","status":"completed"},"tags":[],"execution":{"iopub.status.busy":"2024-08-27T17:24:14.522735Z","iopub.status.idle":"2024-08-27T17:24:14.523206Z","shell.execute_reply.started":"2024-08-27T17:24:14.522959Z","shell.execute_reply":"2024-08-27T17:24:14.522982Z"},"trusted":true},"execution_count":null,"outputs":[]},{"cell_type":"code","source":"# Get seasonality of last months (Dec 2021) of the time series\ndecomposition = seasonal_decompose(df.tail(30).Close)\nfig = decomposition.plot()\nfig.set_size_inches((12, 10))\nfig.tight_layout()\nplt.grid(True)\nplt.show()","metadata":{"papermill":{"duration":0.989312,"end_time":"2022-06-19T13:09:19.090566","exception":false,"start_time":"2022-06-19T13:09:18.101254","status":"completed"},"tags":[],"execution":{"iopub.status.busy":"2024-08-27T17:24:14.525562Z","iopub.status.idle":"2024-08-27T17:24:14.526167Z","shell.execute_reply.started":"2024-08-27T17:24:14.525842Z","shell.execute_reply":"2024-08-27T17:24:14.525872Z"},"trusted":true},"execution_count":null,"outputs":[]},{"cell_type":"markdown","source":"There is a weekly seasonality, but its contribution is very small, so it can be neglected.","metadata":{"papermill":{"duration":0.20744,"end_time":"2022-06-19T13:09:19.476182","exception":false,"start_time":"2022-06-19T13:09:19.268742","status":"completed"},"tags":[]}},{"cell_type":"markdown","source":"### 3.6. EDA with Pandas Profiling Report <a class=\"anchor\" id=\"3.6\"></a>\n\n[Back to Table of Contents](#0.1)","metadata":{"papermill":{"duration":0.175641,"end_time":"2022-06-19T13:09:19.830728","exception":false,"start_time":"2022-06-19T13:09:19.655087","status":"completed"},"tags":[]}},{"cell_type":"code","source":"%%time\nif is_EDA_with_Pandas_Profiling:\n    profile = df.profile_report(title='Pandas Profiling Report for dataset')\n    profile.to_file(output_file=\"profile.html\")\n    display(profile)","metadata":{"papermill":{"duration":18.137268,"end_time":"2022-06-19T13:09:38.145782","exception":false,"start_time":"2022-06-19T13:09:20.008514","status":"completed"},"tags":[],"execution":{"iopub.status.busy":"2024-08-27T17:24:14.527903Z","iopub.status.idle":"2024-08-27T17:24:14.528482Z","shell.execute_reply.started":"2024-08-27T17:24:14.528189Z","shell.execute_reply":"2024-08-27T17:24:14.528220Z"},"trusted":true},"execution_count":null,"outputs":[]},{"cell_type":"markdown","source":"## 4. FE <a class=\"anchor\" id=\"4\"></a>\n\n[Back to Table of Contents](#0.1)","metadata":{"papermill":{"duration":0.349312,"end_time":"2022-06-19T13:09:38.870185","exception":false,"start_time":"2022-06-19T13:09:38.520873","status":"completed"},"tags":[]}},{"cell_type":"markdown","source":"### 4.1. FE with TSFRESH<a class=\"anchor\" id=\"4.1\"></a>\n\n[Back to Table of Contents](#0.1)","metadata":{"papermill":{"duration":0.352513,"end_time":"2022-06-19T13:09:39.577470","exception":false,"start_time":"2022-06-19T13:09:39.224957","status":"completed"},"tags":[]}},{"cell_type":"code","source":"def get_tsfresh_features(data):\n    # Get statistic features using library TSFRESH \n    # Thanks to https://www.kaggle.com/code/vbmokin/btc-growth-forecasting-with-advanced-fe-for-ohlc\n    \n    data = data.reset_index(drop=False).reset_index(drop=False)\n    \n    # Extract features\n    extracted_features = extract_features(data, column_id=\"Date\", column_sort=\"Date\")\n    \n    # Drop features with NaN\n    extracted_features_clean = extracted_features.dropna(axis=1, how='all').reset_index(drop=True)\n    \n    # Drop features with constants\n    cols_std_zero  = []\n    for col in extracted_features_clean.columns:\n        if extracted_features_clean[col].std()==0:\n            cols_std_zero.append(col)\n    extracted_features_clean = extracted_features_clean.drop(columns = cols_std_zero)\n\n    extracted_features_clean['Date'] = data['Date']   # For the merging\n    \n    return extracted_features_clean","metadata":{"papermill":{"duration":0.365777,"end_time":"2022-06-19T13:09:40.294377","exception":false,"start_time":"2022-06-19T13:09:39.928600","status":"completed"},"tags":[],"execution":{"iopub.status.busy":"2024-08-27T17:24:14.530838Z","iopub.status.idle":"2024-08-27T17:24:14.531445Z","shell.execute_reply.started":"2024-08-27T17:24:14.531129Z","shell.execute_reply":"2024-08-27T17:24:14.531160Z"},"trusted":true},"execution_count":null,"outputs":[]},{"cell_type":"code","source":"%%time\n# FE with TSFRESH\nextracted_features_clean = get_tsfresh_features(df[['Close']])\nextracted_features_clean","metadata":{"papermill":{"duration":24.36776,"end_time":"2022-06-19T13:10:05.015331","exception":false,"start_time":"2022-06-19T13:09:40.647571","status":"completed"},"tags":[],"execution":{"iopub.status.busy":"2024-08-27T17:24:14.533588Z","iopub.status.idle":"2024-08-27T17:24:14.534205Z","shell.execute_reply.started":"2024-08-27T17:24:14.533861Z","shell.execute_reply":"2024-08-27T17:24:14.533890Z"},"trusted":true},"execution_count":null,"outputs":[]},{"cell_type":"code","source":"extracted_features_clean.describe()","metadata":{"papermill":{"duration":0.477097,"end_time":"2022-06-19T13:10:05.857704","exception":false,"start_time":"2022-06-19T13:10:05.380607","status":"completed"},"tags":[],"execution":{"iopub.status.busy":"2024-08-27T17:24:14.536009Z","iopub.status.idle":"2024-08-27T17:24:14.536605Z","shell.execute_reply.started":"2024-08-27T17:24:14.536309Z","shell.execute_reply":"2024-08-27T17:24:14.536338Z"},"trusted":true},"execution_count":null,"outputs":[]},{"cell_type":"code","source":"# Extracted features by TSFRESH with cleaning\nextracted_features_clean.columns.tolist()","metadata":{"papermill":{"duration":0.36234,"end_time":"2022-06-19T13:10:06.588173","exception":false,"start_time":"2022-06-19T13:10:06.225833","status":"completed"},"tags":[],"execution":{"iopub.status.busy":"2024-08-27T17:24:14.538284Z","iopub.status.idle":"2024-08-27T17:24:14.538735Z","shell.execute_reply.started":"2024-08-27T17:24:14.538515Z","shell.execute_reply":"2024-08-27T17:24:14.538538Z"},"trusted":true},"execution_count":null,"outputs":[]},{"cell_type":"code","source":"# Get all features\ndf = pd.merge(df, extracted_features_clean, how='left', on='Date')\ndf","metadata":{"papermill":{"duration":0.435801,"end_time":"2022-06-19T13:10:07.391897","exception":false,"start_time":"2022-06-19T13:10:06.956096","status":"completed"},"tags":[],"execution":{"iopub.status.busy":"2024-08-27T17:24:14.540176Z","iopub.status.idle":"2024-08-27T17:24:14.540610Z","shell.execute_reply.started":"2024-08-27T17:24:14.540391Z","shell.execute_reply":"2024-08-27T17:24:14.540414Z"},"trusted":true},"execution_count":null,"outputs":[]},{"cell_type":"code","source":"df.shape","metadata":{"papermill":{"duration":0.494298,"end_time":"2022-06-19T13:10:08.348697","exception":false,"start_time":"2022-06-19T13:10:07.854399","status":"completed"},"tags":[],"execution":{"iopub.status.busy":"2024-08-27T17:24:14.541965Z","iopub.status.idle":"2024-08-27T17:24:14.542430Z","shell.execute_reply.started":"2024-08-27T17:24:14.542212Z","shell.execute_reply":"2024-08-27T17:24:14.542235Z"},"trusted":true},"execution_count":null,"outputs":[]},{"cell_type":"markdown","source":"### 4.2. FE from technical features (Finance knowledge and Data Science)<a class=\"anchor\" id=\"4.2\"></a>\n\n[Back to Table of Contents](#0.1)","metadata":{"papermill":{"duration":0.60704,"end_time":"2022-06-19T13:10:09.481687","exception":false,"start_time":"2022-06-19T13:10:08.874647","status":"completed"},"tags":[]}},{"cell_type":"markdown","source":"The description of these features and more complex options are described in the scientific paper **Mokin V.B., etc.\"Information Technology for the Cryptocurrency Rate Forecasting on the Basics of Complex Feature Engineering\". [Visnyk VPI](https://visnyk.vntu.edu.ua/index.php/visnyk). No 2 (2022).**","metadata":{"papermill":{"duration":0.50074,"end_time":"2022-06-19T13:10:10.452200","exception":false,"start_time":"2022-06-19T13:10:09.951460","status":"completed"},"tags":[]}},{"cell_type":"code","source":"def get_add_features(df_feat):\n    # FE for data as row of DataFrame\n    # Thanks to https://www.kaggle.com/code/vbmokin/g-research-crypto-forecasting-baseline-fe\n    \n    # Two new features from the competition tutorial\n    df_feat['Upper_Shadow'] = df_feat['High'] - np.maximum(df_feat['Close'], df_feat['Open'])\n    df_feat['Lower_Shadow'] = np.minimum(df_feat['Close'], df_feat['Open']) - df_feat['Low']\n    \n    # Thanks to https://www.kaggle.com/code1110/gresearch-simple-lgb-starter\n    df_feat['lower_shadow'] = np.minimum(df_feat['Close'], df_feat['Open']) - df_feat['Low']\n    df_feat['high2low'] = (df_feat['High'] / df_feat['Low']).replace([np.inf, -np.inf, np.nan], 0.)\n    \n    return df_feat","metadata":{"papermill":{"duration":0.531031,"end_time":"2022-06-19T13:10:11.486378","exception":false,"start_time":"2022-06-19T13:10:10.955347","status":"completed"},"tags":[],"execution":{"iopub.status.busy":"2024-08-27T17:24:14.543821Z","iopub.status.idle":"2024-08-27T17:24:14.544286Z","shell.execute_reply.started":"2024-08-27T17:24:14.544028Z","shell.execute_reply":"2024-08-27T17:24:14.544053Z"},"trusted":true},"execution_count":null,"outputs":[]},{"cell_type":"markdown","source":"**TASK :** It is proposed to experiment with FE : add new features and modify existing ones","metadata":{"papermill":{"duration":0.50966,"end_time":"2022-06-19T13:10:12.491065","exception":false,"start_time":"2022-06-19T13:10:11.981405","status":"completed"},"tags":[]}},{"cell_type":"code","source":"# FE - add features\ndf = get_add_features(df)\ndf","metadata":{"papermill":{"duration":0.611881,"end_time":"2022-06-19T13:10:13.590599","exception":false,"start_time":"2022-06-19T13:10:12.978718","status":"completed"},"tags":[],"execution":{"iopub.status.busy":"2024-08-27T17:24:14.545664Z","iopub.status.idle":"2024-08-27T17:24:14.546060Z","shell.execute_reply.started":"2024-08-27T17:24:14.545857Z","shell.execute_reply":"2024-08-27T17:24:14.545877Z"},"trusted":true},"execution_count":null,"outputs":[]},{"cell_type":"markdown","source":"### 4.3. Analysis of anomalies<a class=\"anchor\" id=\"4.3\"></a>\n\n[Back to Table of Contents](#0.1)","metadata":{"papermill":{"duration":0.576145,"end_time":"2022-06-19T13:10:14.668632","exception":false,"start_time":"2022-06-19T13:10:14.092487","status":"completed"},"tags":[]}},{"cell_type":"markdown","source":"#### 4.3.1. Analysis of anomalies for \"Close\"<a class=\"anchor\" id=\"4.3.1\"></a>\n\n[Back to Table of Contents](#0.1)","metadata":{"papermill":{"duration":0.553981,"end_time":"2022-06-19T13:10:15.753416","exception":false,"start_time":"2022-06-19T13:10:15.199435","status":"completed"},"tags":[]}},{"cell_type":"code","source":"# Drawing plot with Plotly\nif is_anomalies:\n    fig = px.line(df, x=\"Date\", y=\"Close\", \n                  title=f\"Investigation of dates of anomalous changes in the cryptocurrency rate\", \n                  log_y=False,template='gridon',width=800, height=600)\n    fig.show()","metadata":{"papermill":{"duration":0.834499,"end_time":"2022-06-19T13:10:17.234024","exception":false,"start_time":"2022-06-19T13:10:16.399525","status":"completed"},"tags":[],"execution":{"iopub.status.busy":"2024-08-27T17:24:14.547673Z","iopub.status.idle":"2024-08-27T17:24:14.548080Z","shell.execute_reply.started":"2024-08-27T17:24:14.547867Z","shell.execute_reply":"2024-08-27T17:24:14.547887Z"},"trusted":true},"execution_count":null,"outputs":[]},{"cell_type":"code","source":"# Synthesis dataframe with anomalous dates for Facebook Prophet\nif is_anomalies:\n    anomalous_dates = ['2021-01-08', '2021-01-27', '2021-04-13', '2021-07-20',\n                       '2021-09-06', '2021-09-29', '2021-11-08', '2021-12-17']\n    holidays_df = pd.DataFrame(columns = ['ds', 'lower_window', 'upper_window', 'prior_scale'])\n    holidays_df['ds'] = anomalous_dates\n    holidays_df['holiday'] = 'anomalous_dates'\n    holidays_df['lower_window'] = 0\n    holidays_df['upper_window'] = 0\n    holidays_df['prior_scale'] = 10\n    display(holidays_df)","metadata":{"papermill":{"duration":0.622182,"end_time":"2022-06-19T13:10:18.507911","exception":false,"start_time":"2022-06-19T13:10:17.885729","status":"completed"},"tags":[],"execution":{"iopub.status.busy":"2024-08-27T17:24:14.549577Z","iopub.status.idle":"2024-08-27T17:24:14.550024Z","shell.execute_reply.started":"2024-08-27T17:24:14.549789Z","shell.execute_reply":"2024-08-27T17:24:14.549812Z"},"trusted":true},"execution_count":null,"outputs":[]},{"cell_type":"code","source":"def plot_with_anomalies(df, cols_y_list, cols_y_list_name, dates_x, anomalous_dates, log_y=False):\n    # Thanks to https://www.kaggle.com/vbmokin/covid-in-ua-prophet-with-4-nd-seasonality\n    # Draws a plot with title - the features cols_y_list (y) and dates_x (x) from the dataframe df\n    # and with vertical lines in the dates from the list anomalous_dates\n    # with the length between the minimum and maximum of feature cols_y_list[0]\n    # with log_y = False or True\n    # cols_y_list - dictionary of the names of cols from cols_y_list (keys - name of feature, value - it's name for the plot legend), \n    # name of cols_y_list[0] is the title of the all plot\n    \n    fig = px.line(df, x=dates_x, y=cols_y_list[0], title=cols_y_list_name[cols_y_list[0]], log_y=log_y, template='gridon',width=800, height=600)\n    y_max = df[cols_y_list[0]].max()\n    for i in range(len(cols_y_list)-1):\n        fig.add_trace(go.Scatter(x=df[dates_x], y=df[cols_y_list[i+1]], mode='lines', name=cols_y_list_name[cols_y_list[i+1]]))\n        max_i = df[cols_y_list[i+1]].max()\n        y_max = max_i if max_i > y_max else y_max\n    \n    y_min = min(df[cols_y_list[0]].min(),0)\n    for i in range(len(anomalous_dates)):\n        anomal_date = anomalous_dates[i]\n        #print(anomal_date, y_min, y_max)\n        fig.add_shape(dict(type=\"line\", x0=anomal_date, y0=y_min, x1=anomal_date, y1=y_max, line=dict(color=\"red\", width=1)))\n    fig.show()","metadata":{"papermill":{"duration":0.629614,"end_time":"2022-06-19T13:10:19.851784","exception":false,"start_time":"2022-06-19T13:10:19.222170","status":"completed"},"tags":[],"execution":{"iopub.status.busy":"2024-08-27T17:24:14.551831Z","iopub.status.idle":"2024-08-27T17:24:14.552440Z","shell.execute_reply.started":"2024-08-27T17:24:14.552122Z","shell.execute_reply":"2024-08-27T17:24:14.552153Z"},"trusted":true},"execution_count":null,"outputs":[]},{"cell_type":"code","source":"# Draw plot\nif is_anomalies:\n    plot_with_anomalies(df, [\"Close\"], \n                        {\"Close\" : f\"Anomalous dates for {cryptocurrency}\"}, \n                        'Date', anomalous_dates, False)","metadata":{"papermill":{"duration":0.494029,"end_time":"2022-06-19T13:10:20.865505","exception":false,"start_time":"2022-06-19T13:10:20.371476","status":"completed"},"tags":[],"execution":{"iopub.status.busy":"2024-08-27T17:24:14.554573Z","iopub.status.idle":"2024-08-27T17:24:14.555221Z","shell.execute_reply.started":"2024-08-27T17:24:14.554866Z","shell.execute_reply":"2024-08-27T17:24:14.554895Z"},"trusted":true},"execution_count":null,"outputs":[]},{"cell_type":"markdown","source":"If we simulate the first data difference \"Close_diff\", then other anomalies will be added, when not just an unexpected change, but when it was very large.","metadata":{"papermill":{"duration":0.36931,"end_time":"2022-06-19T13:10:21.643153","exception":false,"start_time":"2022-06-19T13:10:21.273843","status":"completed"},"tags":[]}},{"cell_type":"markdown","source":"#### 4.3.2. Analysis of anomalies for the first data difference \"Close_diff\"<a class=\"anchor\" id=\"4.3.2\"></a>\n\n[Back to Table of Contents](#0.1)","metadata":{"papermill":{"duration":0.366649,"end_time":"2022-06-19T13:10:22.406156","exception":false,"start_time":"2022-06-19T13:10:22.039507","status":"completed"},"tags":[]}},{"cell_type":"code","source":"# Drawing plot with Plotly\nif is_anomalies:\n    fig = px.line(df, x=\"Date\", y=\"Close_diff\", \n                  title=f\"Investigation of dates of anomalous changes in the first difference of the cryptocurrency rate\", \n                  log_y=False,template='gridon',width=800, height=600)\n    fig.show()","metadata":{"papermill":{"duration":0.446606,"end_time":"2022-06-19T13:10:23.229180","exception":false,"start_time":"2022-06-19T13:10:22.782574","status":"completed"},"tags":[],"execution":{"iopub.status.busy":"2024-08-27T17:24:14.557075Z","iopub.status.idle":"2024-08-27T17:24:14.557543Z","shell.execute_reply.started":"2024-08-27T17:24:14.557317Z","shell.execute_reply":"2024-08-27T17:24:14.557340Z"},"trusted":true},"execution_count":null,"outputs":[]},{"cell_type":"code","source":"# Add new anomalous dates\nif is_anomalies:\n    anomalous_dates_diff = anomalous_dates.copy()\n    anomalous_dates_diff.append('2021-02-08')\n    anomalous_dates_diff.append('2021-05-12')\n    anomalous_dates_diff.append('2021-09-07')\n    print(anomalous_dates_diff)","metadata":{"papermill":{"duration":0.382592,"end_time":"2022-06-19T13:10:24.022862","exception":false,"start_time":"2022-06-19T13:10:23.640270","status":"completed"},"tags":[],"execution":{"iopub.status.busy":"2024-08-27T17:24:14.559167Z","iopub.status.idle":"2024-08-27T17:24:14.559750Z","shell.execute_reply.started":"2024-08-27T17:24:14.559451Z","shell.execute_reply":"2024-08-27T17:24:14.559481Z"},"trusted":true},"execution_count":null,"outputs":[]},{"cell_type":"code","source":"# Synthesis dataframe with anomalous dates for Facebook Prophet\nif is_anomalies:\n    holidays_df_diff = pd.DataFrame(columns = ['ds', 'lower_window', 'upper_window', 'prior_scale'])\n    holidays_df_diff['ds'] = anomalous_dates_diff\n    holidays_df_diff['holiday'] = 'anomalous_dates_for_difference'\n    holidays_df_diff['lower_window'] = 0\n    holidays_df_diff['upper_window'] = 0\n    holidays_df_diff['prior_scale'] = 10\n    display(holidays_df_diff)","metadata":{"papermill":{"duration":0.403935,"end_time":"2022-06-19T13:10:24.813300","exception":false,"start_time":"2022-06-19T13:10:24.409365","status":"completed"},"tags":[],"execution":{"iopub.status.busy":"2024-08-27T17:24:14.561658Z","iopub.status.idle":"2024-08-27T17:24:14.562118Z","shell.execute_reply.started":"2024-08-27T17:24:14.561875Z","shell.execute_reply":"2024-08-27T17:24:14.561897Z"},"trusted":true},"execution_count":null,"outputs":[]},{"cell_type":"code","source":"# Draw plot\nif is_anomalies:\n    plot_with_anomalies(df, [\"Close_diff\"], \n                        {\"Close_diff\" : f\"Anomalous dates for the first difference of the {cryptocurrency}\"}, \n                        'Date', anomalous_dates_diff, False)","metadata":{"papermill":{"duration":0.508383,"end_time":"2022-06-19T13:10:25.721399","exception":false,"start_time":"2022-06-19T13:10:25.213016","status":"completed"},"tags":[],"execution":{"iopub.status.busy":"2024-08-27T17:24:14.563751Z","iopub.status.idle":"2024-08-27T17:24:14.564350Z","shell.execute_reply.started":"2024-08-27T17:24:14.564020Z","shell.execute_reply":"2024-08-27T17:24:14.564049Z"},"trusted":true},"execution_count":null,"outputs":[]},{"cell_type":"code","source":"# Synthesis a new feature in df for anomalous_dates_diff\nif is_anomalies:\n    df['Close_diff_anomalous'] = df['Date'].isin(anomalous_dates_diff).astype('int')    \n    display(df)\n    \n    # Number of anomalous dates\n    print(f\"Number of anomalous dates - {df['Close_diff_anomalous'].sum()}\")","metadata":{"papermill":{"duration":0.428436,"end_time":"2022-06-19T13:10:26.554012","exception":false,"start_time":"2022-06-19T13:10:26.125576","status":"completed"},"tags":[],"execution":{"iopub.status.busy":"2024-08-27T17:24:14.566159Z","iopub.status.idle":"2024-08-27T17:24:14.566774Z","shell.execute_reply.started":"2024-08-27T17:24:14.566436Z","shell.execute_reply":"2024-08-27T17:24:14.566466Z"},"trusted":true},"execution_count":null,"outputs":[]},{"cell_type":"markdown","source":"### 4.4. Analysis of the impact of COVID-19 on the cryptocurrency rate <a class=\"anchor\" id=\"4.4\"></a>\n\n[Back to Table of Contents](#0.1)\n\n#### From the notebook [BTC & COVID-19 in USA : EDA & Prediction](https://www.kaggle.com/code/vbmokin/btc-covid-19-in-usa-eda-prediction)","metadata":{"papermill":{"duration":0.38318,"end_time":"2022-06-19T13:10:27.339833","exception":false,"start_time":"2022-06-19T13:10:26.956653","status":"completed"},"tags":[]}},{"cell_type":"code","source":"# Set COVID parameters\nif is_EDA_with_COVID19_data:\n    covid_feature = 'New_Deaths'  # or \"New_Cases\"\n    country_covid_feature = f\"USA_{covid_feature}\"\n    print('country_covid_feature =', country_covid_feature)","metadata":{"papermill":{"duration":0.393909,"end_time":"2022-06-19T13:10:28.134182","exception":false,"start_time":"2022-06-19T13:10:27.740273","status":"completed"},"tags":[],"execution":{"iopub.status.busy":"2024-08-27T17:24:14.568468Z","iopub.status.idle":"2024-08-27T17:24:14.569035Z","shell.execute_reply.started":"2024-08-27T17:24:14.568736Z","shell.execute_reply":"2024-08-27T17:24:14.568765Z"},"trusted":true},"execution_count":null,"outputs":[]},{"cell_type":"code","source":"def get_covid_data(date_start, covid_feature, country='USA'):\n\n    # Thanks https://www.kaggle.com/vbmokin/covid-19-in-70-countries-daily-prophet-forecast\n    # Source: https://github.com/CSSEGISandData/COVID-19/tree/master/csse_covid_19_data/csse_covid_19_time_series\n    \n    if covid_feature=='New_Cases':\n        file = \"time_series_covid19_confirmed_global.csv\"\n        name_feature = 'Cases'\n    elif covid_feature==\"New_Deaths\":\n        file = \"time_series_covid19_deaths_global.csv\"\n        name_feature = 'Deaths'\n    \n    myfile = requests.get(f'https://raw.githubusercontent.com/CSSEGISandData/COVID-19/master/csse_covid_19_data/csse_covid_19_time_series/{file}')\n    open('data', 'wb').write(myfile.content)\n    global_df = pd.read_csv('data')\n    \n    if country=='USA':\n        code = 'US'\n    else: code = country\n    \n    try:\n        global_df = global_df[global_df['Country/Region']==code]\n    except:\n        print('Non-existent country code given')\n        return None\n\n    def convert_date_str(df):\n        try:\n            df.columns = list(df.columns[:4]) + [datetime.strptime(d, \"%m/%d/%y\").date().strftime(\"%Y-%m-%d\") for d in df.columns[4:]]\n        except:\n            print('_convert_date_str failed with %y, try %Y')\n            df.columns = list(df.columns[:4]) + [datetime.strptime(d, \"%m/%d/%Y\").date().strftime(\"%Y-%m-%d\") for d in df.columns[4:]]\n\n    convert_date_str(global_df)\n    \n    global_df2 = global_df.melt(\n        id_vars=['Province/State', 'Country/Region', 'Lat', 'Long'], value_vars=global_df.columns[4:], var_name='Date', value_name=name_feature)\n\n    df_covid = global_df2[['Date', name_feature]]\n    df_covid[name_feature] = df_covid[name_feature].astype('int').diff()\n    df_covid = df_covid.fillna(0)\n\n    df_covid['ds'] = pd.to_datetime(df_covid['Date'])\n    df_covid = df_covid[df_covid['ds'] > date_start][['ds', name_feature]].reset_index(drop=True)\n    df_covid.columns = ['Date', country_covid_feature]\n\n    return df_covid\n\nif is_EDA_with_COVID19_data:\n    df_covid = get_covid_data(date_start, covid_feature)","metadata":{"papermill":{"duration":0.705122,"end_time":"2022-06-19T13:10:29.235981","exception":false,"start_time":"2022-06-19T13:10:28.530859","status":"completed"},"tags":[],"execution":{"iopub.status.busy":"2024-08-27T17:24:14.571201Z","iopub.status.idle":"2024-08-27T17:24:14.571805Z","shell.execute_reply.started":"2024-08-27T17:24:14.571500Z","shell.execute_reply":"2024-08-27T17:24:14.571529Z"},"trusted":true},"execution_count":null,"outputs":[]},{"cell_type":"code","source":"def df_covid_data_imputing(df_covid):\n    # Imputing COVID data for USA\n\n    def pd_imputing(df, date1, date2, col):\n        x1 = float(df[df['Date']==date1][col].head(1))\n        x2 = float(df[df['Date']==date2][col].head(1))\n        return (x1+x2)/2\n\n    def df_add(df, date_middle, date1, date2, col=country_covid_feature):\n        # Add imputed COVID data for USA\n        df = df.append({'Date': datetime.strptime(date_middle, '%Y-%m-%d'), col : pd_imputing(df, date1, date2, col=col)}, ignore_index=True)\n        return df\n\n    # Only for USA - the imputing missing data\n    date_anomal = ['2020-10-08', '2020-10-11', '2020-10-12', '2020-10-25']\n    df_covid = df_add(df_covid, '2020-10-08', '2020-10-07', '2020-10-09')\n    df_covid = df_add(df_covid, '2020-10-11', '2020-10-10', '2020-10-13')\n    df_covid = df_add(df_covid, '2020-10-12', '2020-10-11', '2020-10-14')\n    df_covid = df_add(df_covid, '2020-10-25', '2020-10-24', '2020-10-26')\n    df_covid = df_covid.sort_values(by=['Date']).reset_index(drop=True)\n    \n    return df_covid\n\nif is_EDA_with_COVID19_data:\n    df_covid = df_covid_data_imputing(df_covid)\n    display(df_covid)","metadata":{"papermill":{"duration":0.434518,"end_time":"2022-06-19T13:10:30.064072","exception":false,"start_time":"2022-06-19T13:10:29.629554","status":"completed"},"tags":[],"execution":{"iopub.status.busy":"2024-08-27T17:24:14.573022Z","iopub.status.idle":"2024-08-27T17:24:14.573518Z","shell.execute_reply.started":"2024-08-27T17:24:14.573296Z","shell.execute_reply":"2024-08-27T17:24:14.573320Z"},"trusted":true},"execution_count":null,"outputs":[]},{"cell_type":"code","source":"if is_EDA_with_COVID19_data:\n    data = pd.merge(df[['Date', 'Close']], df_covid, on = 'Date')\n    data.index = data['Date']\n    display(data)","metadata":{"papermill":{"duration":0.4104,"end_time":"2022-06-19T13:10:30.883359","exception":false,"start_time":"2022-06-19T13:10:30.472959","status":"completed"},"tags":[],"execution":{"iopub.status.busy":"2024-08-27T17:24:14.574878Z","iopub.status.idle":"2024-08-27T17:24:14.575338Z","shell.execute_reply.started":"2024-08-27T17:24:14.575114Z","shell.execute_reply":"2024-08-27T17:24:14.575141Z"},"trusted":true},"execution_count":null,"outputs":[]},{"cell_type":"code","source":"def draw_crypto_and_covid(data):\n    # Displays COVID data in USA and cryptocurrency data on one plot\n    \n    def df_minmax_scaler(df):\n        # Data Scalling\n        index_df = df.pop('Date')\n        scaler = MinMaxScaler().fit(df)\n        df = pd.DataFrame(scaler.transform(df), columns = df.columns, index = index_df)\n        return df\n\n    data = df_minmax_scaler(data.copy())\n\n    # Data smoothing and visualization\n    cols_scaled = ['Close_Smoothed_Scaled', country_covid_feature + \"_Smoothed_Scaled\"]\n    data.columns = cols_scaled\n    for col in cols_scaled:\n        data[col] = data[col].rolling(7).mean()\n    data[cols_scaled].plot(lw=4, grid=True, figsize=(12,10))\n\nif is_EDA_with_COVID19_data:\n    draw_crypto_and_covid(data)","metadata":{"papermill":{"duration":0.737718,"end_time":"2022-06-19T13:10:32.030812","exception":false,"start_time":"2022-06-19T13:10:31.293094","status":"completed"},"tags":[],"execution":{"iopub.status.busy":"2024-08-27T17:24:14.577274Z","iopub.status.idle":"2024-08-27T17:24:14.577681Z","shell.execute_reply.started":"2024-08-27T17:24:14.577478Z","shell.execute_reply":"2024-08-27T17:24:14.577498Z"},"trusted":true},"execution_count":null,"outputs":[]},{"cell_type":"code","source":"# Saving the dataset\nif is_EDA_with_COVID19_data:\n    df.to_csv(f'data_of_{cryptocurrency}.csv', index=False)","metadata":{"papermill":{"duration":0.462677,"end_time":"2022-06-19T13:10:32.906373","exception":false,"start_time":"2022-06-19T13:10:32.443696","status":"completed"},"tags":[],"execution":{"iopub.status.busy":"2024-08-27T17:24:14.579047Z","iopub.status.idle":"2024-08-27T17:24:14.579511Z","shell.execute_reply.started":"2024-08-27T17:24:14.579295Z","shell.execute_reply":"2024-08-27T17:24:14.579318Z"},"trusted":true},"execution_count":null,"outputs":[]},{"cell_type":"markdown","source":"### 4.5. Get target, training, validation and test datasets for ML models<a class=\"anchor\" id=\"4.5\"></a>\n\n[Back to Table of Contents](#0.1)","metadata":{"papermill":{"duration":0.39768,"end_time":"2022-06-19T13:10:33.702728","exception":false,"start_time":"2022-06-19T13:10:33.305048","status":"completed"},"tags":[]}},{"cell_type":"code","source":"# Illustration of number transformations in the columns:\n# \"Close\" -> \"Close_diff\" -> \"Target\" -> \"Close_diff_pred\" -> \"Close_pred\"\n# Get target and the result of the forecasting\nforecasting_days_example = 3\ndf_example = pd.DataFrame({'Close':[1, 2, 4, 8, 15, 25], 'Day': [0, 1, 2, 3, 4, 5]})\ndf_example['Close_diff'] = df_example['Close'].diff()\ndf_example['target'] = df_example['Close_diff'].shift(-forecasting_days_example)\ndf_example['target_pred'] = df_example['target'].copy()   # Ideal forecasting result\nprint(f'Simulation of the result of ideal forecasting the \"target_pred\" for {forecasting_days_example} days')\ndisplay(df_example[['Day', 'Close', 'Close_diff', 'target', 'target_pred']])\n\n# Get inverse target\nprint('\\nSimulation of the recovering predicted values \"Close_pred\" from the \"target_pred\"')\ndf_example['Close_diff_pred_shifted'] = df_example['target_pred'].shift(forecasting_days_example)\n\n# Let's create an intermediate feature to make it easier to explain the transformation\ntemp_column_name = f'Close_diff_pred_shifted_with_Close'  # Intermediate feature for transformations \ndf_example[temp_column_name] = df_example['Close_diff_pred_shifted'].copy()\ndf_example.loc[forecasting_days_example, temp_column_name] = df_example.loc[forecasting_days_example,'Close']\ndf_example['Close_pred'] = np.concatenate((df_example['Close'].tolist()[:forecasting_days_example], \n                                           np.cumsum(df_example[temp_column_name].values[forecasting_days_example:], dtype=float)))\ndf_example['Close_pred'] = df_example['Close_pred'].astype('int')\ndisplay(df_example[['Day', 'Close', 'Close_diff', 'target', 'target_pred', 'Close_diff_pred_shifted', temp_column_name, 'Close_pred']])","metadata":{"papermill":{"duration":0.445115,"end_time":"2022-06-19T13:10:34.544228","exception":false,"start_time":"2022-06-19T13:10:34.099113","status":"completed"},"tags":[],"execution":{"iopub.status.busy":"2024-08-27T17:24:14.581427Z","iopub.status.idle":"2024-08-27T17:24:14.581865Z","shell.execute_reply.started":"2024-08-27T17:24:14.581642Z","shell.execute_reply":"2024-08-27T17:24:14.581664Z"},"trusted":true},"execution_count":null,"outputs":[]},{"cell_type":"markdown","source":"1. Recovery is possible if you know exactly at least one value \"Close\".\n2. If the last N values for the time series will be in the target_test, then during the comparing with the output of other multi-features ML models needs remember that in them the target is shifted back and taken with a difference.\n3. Target for Time series model is \"Close\". \n4. Target is for multi-factors models is \"target_pred\" = shifted \"Close_diff\".","metadata":{"papermill":{"duration":0.400748,"end_time":"2022-06-19T13:10:35.456668","exception":false,"start_time":"2022-06-19T13:10:35.055920","status":"completed"},"tags":[]}},{"cell_type":"code","source":"def cut_data(df, y, num_start, num_end):\n    # Cutting dataframe df and array or list for [num_start, num_end-1]        \n    df2 = df[num_start:(num_end+1)]\n    y2 = y[num_start:(num_end+1)] if y is not None else None\n    return df2, y2","metadata":{"papermill":{"duration":0.411313,"end_time":"2022-06-19T13:10:36.278209","exception":false,"start_time":"2022-06-19T13:10:35.866896","status":"completed"},"tags":[],"execution":{"iopub.status.busy":"2024-08-27T17:24:14.584536Z","iopub.status.idle":"2024-08-27T17:24:14.584989Z","shell.execute_reply.started":"2024-08-27T17:24:14.584764Z","shell.execute_reply":"2024-08-27T17:24:14.584790Z"},"trusted":true},"execution_count":null,"outputs":[]},{"cell_type":"code","source":"def get_target_mf(df, forecasting_days, col='Close'):\n    # Get target as difference of the df[col] \n    # Returns target which is shifted for forecasting_days days in the dataframe df\n    # \"Close\" -> \"Close_diff\" -> \"Target\" \n    col_diff = f\"{col}_diff\"\n    df[col_diff] = df['Close'].diff()\n    df['target'] = df[col_diff].shift(-forecasting_days)\n    df = df.drop(columns=[col_diff]).dropna()\n    \n    return df","metadata":{"papermill":{"duration":0.412536,"end_time":"2022-06-19T13:10:37.117447","exception":false,"start_time":"2022-06-19T13:10:36.704911","status":"completed"},"tags":[],"execution":{"iopub.status.busy":"2024-08-27T17:24:14.586372Z","iopub.status.idle":"2024-08-27T17:24:14.586936Z","shell.execute_reply.started":"2024-08-27T17:24:14.586642Z","shell.execute_reply":"2024-08-27T17:24:14.586672Z"},"trusted":true},"execution_count":null,"outputs":[]},{"cell_type":"code","source":"def get_train_valid_test_ts(df, forecasting_days, target='Close'):\n    # Get training, validation and test datasets with target for Time Series models\n    \n    # Data prepairing\n    df = df.dropna(how=\"any\").reset_index(drop=True)\n    df = df[['Date', 'Close']]\n    df.columns = ['ds', 'y']        \n    y = None\n\n    # Data smoothing\n#     df.index = df.ds\n#     df = df.drop(columns=['ds'])\n#     df['y'] = df['y'].rolling(7).mean()\n#     df = df.dropna().reset_index(drop=False)\n    \n    N = len(df)\n    train, _ = cut_data(df, y, 0, N-2*forecasting_days-1)\n    valid, _ = cut_data(df, y, N-2*forecasting_days, N-forecasting_days-1)\n    test, _ = cut_data(df, y, N-forecasting_days, N)\n    \n    # Train+valid - for optimal model training\n    train_valid = pd.concat([train, valid])\n\n    print(f'Origin dataset has {len(df)} rows and {len(df.columns)} features')\n    print(f'Get training dataset with {len(train)} rows')\n    print(f'Get validation dataset with {len(valid)} rows')\n    print(f'Get test dataset with {len(test)} rows')\n    \n    return train, valid, test, train_valid","metadata":{"papermill":{"duration":0.411,"end_time":"2022-06-19T13:10:37.928408","exception":false,"start_time":"2022-06-19T13:10:37.517408","status":"completed"},"tags":[],"execution":{"iopub.status.busy":"2024-08-27T17:24:14.589546Z","iopub.status.idle":"2024-08-27T17:24:14.590134Z","shell.execute_reply.started":"2024-08-27T17:24:14.589813Z","shell.execute_reply":"2024-08-27T17:24:14.589842Z"},"trusted":true},"execution_count":null,"outputs":[]},{"cell_type":"code","source":"def get_train_valid_test_mf(df, forecasting_days, target='target'):\n    # Get training, validation and test datasets with target for multi-features ML models\n    \n    df = df.drop(columns = ['Date']).dropna(how=\"any\").reset_index(drop=True)\n    \n    # Save and drop target        \n    y = df.pop(target)\n\n    # Get starting points for the recovering \"Close\" from \"Close_diff_shigted\"\n    N = len(df)\n    #print(f\"Total - {N}, Valid start index = {N-forecasting_days-1}, Test start index = {N-1}\")\n    start_points = {'valid_start_point' : df.loc[N-forecasting_days-1, 'Close'],\n                    'test_start_point' : df.loc[N-1, 'Close']}\n\n    # Standartization data\n    scaler = StandardScaler()\n    df = pd.DataFrame(scaler.fit_transform(df), columns = df.columns)\n    \n    \n    train, ytrain = cut_data(df.copy(), y, 0, N-2*forecasting_days-1)\n    valid, yvalid = cut_data(df.copy(), y, N-2*forecasting_days, N-forecasting_days-1)\n    test, ytest = cut_data(df.copy(), y, N-forecasting_days, N)\n\n\n    # Train+valid - for optimal model training\n    train_valid = pd.concat([train, valid])\n    y_train_valid = pd.concat([ytrain, yvalid])\n\n    print(f'Origin dataset has {len(df)} rows and {len(df.columns)} features')\n    print(f'Get training dataset with {len(train)} rows')\n    print(f'Get validation dataset with {len(valid)} rows')\n    print(f'Get test dataset with {len(test)} rows')\n    \n    return train, ytrain, valid, yvalid, test, ytest, train_valid, y_train_valid, start_points","metadata":{"papermill":{"duration":0.409859,"end_time":"2022-06-19T13:10:38.739492","exception":false,"start_time":"2022-06-19T13:10:38.329633","status":"completed"},"tags":[],"execution":{"iopub.status.busy":"2024-08-27T17:24:14.592035Z","iopub.status.idle":"2024-08-27T17:24:14.592647Z","shell.execute_reply.started":"2024-08-27T17:24:14.592345Z","shell.execute_reply":"2024-08-27T17:24:14.592375Z"},"trusted":true},"execution_count":null,"outputs":[]},{"cell_type":"markdown","source":"## 5. Model training and forecasting <a class=\"anchor\" id=\"5\"></a>\n\n[Back to Table of Contents](#0.1)","metadata":{"papermill":{"duration":0.397701,"end_time":"2022-06-19T13:10:39.539243","exception":false,"start_time":"2022-06-19T13:10:39.141542","status":"completed"},"tags":[]}},{"cell_type":"markdown","source":"This section provides examples of identifying the following models (but the list goes on):\n* Facebook Prophet \n* ARIMA (and AutoARIMA)\n* Linear Regression\n* KNeighbors Regressor\n* Support Vector Machines\n* Linear SVR\n* Random Forest Regressor\n* Bagging Regressor\n* XGB Regressor\n* MLP Regressor\n\nFB Prophet and ARIMA models have a slightly different data format, while other Machine Learning (ML) models have the same data, so it is easy to increase their number.\n\nClassic model XGBoost have a special format, but this notebook  uses its simplified version, which work in a data format similar to the models of the Sklearn library.\n\nModels based on neural networks (based on PyTorch or Keras) and ensembles of all these models are more effective, but this will be done later in other notebooks.","metadata":{"papermill":{"duration":0.400746,"end_time":"2022-06-19T13:10:40.338432","exception":false,"start_time":"2022-06-19T13:10:39.937686","status":"completed"},"tags":[]}},{"cell_type":"code","source":"def calc_metrics(type_score, list_true, list_pred):\n    # Calculation score with type=type_score for list_true and list_pred \n    if type_score=='r2_score':\n        score = r2_score(list_true, list_pred)\n    elif type_score=='rmse':\n        score = mean_squared_error(list_true, list_pred, squared=False)\n    elif type_score=='mape':\n        score = mean_absolute_percentage_error(list_true, list_pred)\n    return score","metadata":{"papermill":{"duration":0.397141,"end_time":"2022-06-19T13:10:41.144020","exception":false,"start_time":"2022-06-19T13:10:40.746879","status":"completed"},"tags":[],"execution":{"iopub.status.busy":"2024-08-27T17:24:14.594265Z","iopub.status.idle":"2024-08-27T17:24:14.594742Z","shell.execute_reply.started":"2024-08-27T17:24:14.594499Z","shell.execute_reply":"2024-08-27T17:24:14.594522Z"},"trusted":true},"execution_count":null,"outputs":[]},{"cell_type":"code","source":"def result_add_metrics(result, n, y_true, y_pred):\n    # Calculation and addition metrics into dataframe result[n,:]\n    \n    result.loc[n,'r2_score'] = calc_metrics('r2_score', y_true, y_pred)\n    result.loc[n,'rmse'] = calc_metrics('rmse', y_true, y_pred)      # in coins\n    result.loc[n,'mape'] = 100*calc_metrics('mape', y_true, y_pred)  # in %\n    \n    return result","metadata":{"papermill":{"duration":0.417857,"end_time":"2022-06-19T13:10:41.964564","exception":false,"start_time":"2022-06-19T13:10:41.546707","status":"completed"},"tags":[],"execution":{"iopub.status.busy":"2024-08-27T17:24:14.596004Z","iopub.status.idle":"2024-08-27T17:24:14.596464Z","shell.execute_reply.started":"2024-08-27T17:24:14.596247Z","shell.execute_reply":"2024-08-27T17:24:14.596270Z"},"trusted":true},"execution_count":null,"outputs":[]},{"cell_type":"code","source":"# Results of all models\nresult = pd.DataFrame(columns = ['name_model', 'type_data', 'r2_score', 'rmse', 'mape', 'params', 'ypred'])","metadata":{"papermill":{"duration":0.407984,"end_time":"2022-06-19T13:10:42.770906","exception":false,"start_time":"2022-06-19T13:10:42.362922","status":"completed"},"tags":[],"execution":{"iopub.status.busy":"2024-08-27T17:24:14.598443Z","iopub.status.idle":"2024-08-27T17:24:14.598987Z","shell.execute_reply.started":"2024-08-27T17:24:14.598667Z","shell.execute_reply":"2024-08-27T17:24:14.598690Z"},"trusted":true},"execution_count":null,"outputs":[]},{"cell_type":"markdown","source":"### 5.1. Facebook Prophet <a class=\"anchor\" id=\"5.1\"></a>\n\n[Back to Table of Contents](#0.1)","metadata":{"papermill":{"duration":0.400336,"end_time":"2022-06-19T13:10:43.572394","exception":false,"start_time":"2022-06-19T13:10:43.172058","status":"completed"},"tags":[]}},{"cell_type":"markdown","source":"\nThe best instruction for these models and technology: https://facebook.github.io/prophet/docs/quick_start.html\n\nYou can try to use additional features to improve forecasting, but this will be done in other notebooks later.\n\nThe FB Prophet model is effective only for the values of the series themselves, and not for its differences, which are too noisy.\n\nAnalysis showed that a number of values of the series differ significantly in 2020 Years data compare and 2021 (see [Cryptocurrency : Years data comparing with AutoViz](https://www.kaggle.com/vbmokin/cryptocurrency-years-data-comparing-with-autoviz)), so to increase the accuracy of the forecast, it is proposed to model only 2021 using FB Prophet.","metadata":{"papermill":{"duration":0.40203,"end_time":"2022-06-19T13:10:44.373196","exception":false,"start_time":"2022-06-19T13:10:43.971166","status":"completed"},"tags":[]}},{"cell_type":"code","source":"# Modeling 2021 year only\nif is_Prophet:\n    df2 = df[df.Date.dt.year == 2021]\n    display(df2)","metadata":{"papermill":{"duration":0.441581,"end_time":"2022-06-19T13:10:45.214782","exception":false,"start_time":"2022-06-19T13:10:44.773201","status":"completed"},"tags":[],"execution":{"iopub.status.busy":"2024-08-27T17:24:14.600628Z","iopub.status.idle":"2024-08-27T17:24:14.601266Z","shell.execute_reply.started":"2024-08-27T17:24:14.600917Z","shell.execute_reply":"2024-08-27T17:24:14.600947Z"},"trusted":true},"execution_count":null,"outputs":[]},{"cell_type":"code","source":"# Get datasets\nif is_Prophet:\n    train_ts, valid_ts, test_ts, train_valid_ts = get_train_valid_test_ts(df2.copy(), forecasting_days, target='Close')\n    \n    if not is_anomalies:\n        holidays_df = None","metadata":{"papermill":{"duration":0.40861,"end_time":"2022-06-19T13:10:46.034710","exception":false,"start_time":"2022-06-19T13:10:45.626100","status":"completed"},"tags":[],"execution":{"iopub.status.busy":"2024-08-27T17:24:14.603324Z","iopub.status.idle":"2024-08-27T17:24:14.603916Z","shell.execute_reply.started":"2024-08-27T17:24:14.603606Z","shell.execute_reply":"2024-08-27T17:24:14.603639Z"},"trusted":true},"execution_count":null,"outputs":[]},{"cell_type":"code","source":"def prophet_modeling(result, \n                     cryptocurrency, \n                     train, \n                     test, \n                     holidays_df, \n                     period_days,\n                     fourier_order_seasonality,\n                     forecasting_period,\n                     name_model,\n                     type_data):\n    # Performs FB Prophet model training for given train dataset, holidays_df and seasonality_mode\n    # Performs forecasting with period by this model, visualization and error estimation\n    # df - dataframe with real data in the forecasting_period\n    # can be such combinations of parameters: train=train, test=valid or train=train_valid, test=test\n    # Save results into dataframe result\n    \n    # Build Prophet model with parameters and structure \n    model = Prophet(daily_seasonality=False, \n                    weekly_seasonality=False, \n                    yearly_seasonality=False, \n                    changepoint_range=1, \n                    changepoint_prior_scale = 0.5, \n                    holidays=holidays_df, \n                    seasonality_mode = 'multiplicative'\n                   )\n    model.add_seasonality(name='seasonality', period=period_days, \n                          fourier_order=fourier_order_seasonality, \n                          mode = 'multiplicative', prior_scale = 0.5)\n    # Training model for df\n    model.fit(train)\n    \n    # Make a forecast\n    future = model.make_future_dataframe(periods = forecasting_period)\n    forecast = model.predict(future)\n    \n    # Draw plot of the values with forecasting data\n    figure = model.plot(forecast, xlabel = 'Date', ylabel = f\"{name_model} for {cryptocurrency}\")\n    \n    # Draw plot with the components (trend and seasonalities) of the forecasts\n    figure_component = model.plot_components(forecast)\n    \n    # Ouput the prediction for the next time on forecasted_days\n    #forecast[['yhat_lower', 'yhat', 'yhat_upper']] = forecast[['yhat_lower', 'yhat', 'yhat_upper']].round(1)\n    #forecast[['ds', 'yhat_lower', 'yhat', 'yhat_upper']].tail(forecasting_period)\n    \n    # Forecasting data by the model\n    ypred = forecast['yhat'][-forecasting_period:]\n    #print(ypred)\n    # Save results\n    n = len(result)\n    result.loc[n,'name_model'] = f\"Prophet_{name_model}\"\n    result.loc[n,'type_data'] = type_data\n    result.at[n,'params'] = [period_days]+[fourier_order_seasonality]\n    result.at[n,'ypred'] = ypred\n    #result = result_add_metrics(result, n, test['y'], y_pred)\n    \n    return result, ypred","metadata":{"papermill":{"duration":0.422253,"end_time":"2022-06-19T13:10:46.864756","exception":false,"start_time":"2022-06-19T13:10:46.442503","status":"completed"},"tags":[],"execution":{"iopub.status.busy":"2024-08-27T17:24:14.606140Z","iopub.status.idle":"2024-08-27T17:24:14.606757Z","shell.execute_reply.started":"2024-08-27T17:24:14.606445Z","shell.execute_reply":"2024-08-27T17:24:14.606475Z"},"trusted":true},"execution_count":null,"outputs":[]},{"cell_type":"markdown","source":"**TASK :** It is proposed to experiment with models parameters","metadata":{"papermill":{"duration":0.425309,"end_time":"2022-06-19T13:10:47.696827","exception":false,"start_time":"2022-06-19T13:10:47.271518","status":"completed"},"tags":[]}},{"cell_type":"code","source":"%%time\n# Models tuning\nif is_Prophet:\n    for period_days in [4, 5, 7, 14]:\n        for fourier_order_seasonality in [3, 12]:\n            result, _ = prophet_modeling(result, \n                                         cryptocurrency, \n                                         train_ts, \n                                         valid_ts, \n                                         holidays_df, \n                                         period_days,\n                                         fourier_order_seasonality,\n                                         forecasting_days,\n                                         f'{period_days}_days_{fourier_order_seasonality}_order',\n                                         'valid')","metadata":{"papermill":{"duration":30.869491,"end_time":"2022-06-19T13:11:18.968866","exception":false,"start_time":"2022-06-19T13:10:48.099375","status":"completed"},"tags":[],"execution":{"iopub.status.busy":"2024-08-27T17:24:14.608382Z","iopub.status.idle":"2024-08-27T17:24:14.608961Z","shell.execute_reply.started":"2024-08-27T17:24:14.608661Z","shell.execute_reply":"2024-08-27T17:24:14.608693Z"},"trusted":true},"execution_count":null,"outputs":[]},{"cell_type":"markdown","source":"### 5.2. ARIMA <a class=\"anchor\" id=\"5.2\"></a>\n\n[Back to Table of Contents](#0.1)\n\nThis information from the good notebook [ARIMA Model for Time Series Forecasting](https://www.kaggle.com/code/prashant111/arima-model-for-time-series-forecasting)\n\nARIMA stands for Autoregressive Integrated Moving Average Model. It belongs to a class of models that explains a given time series based on its own past values -i.e.- its own lags and the lagged forecast errors. The equation can be used to forecast future values. Any ‘non-seasonal’ time series that exhibits patterns and is not a random white noise can be modeled with ARIMA models.\nSo, ARIMA, short for AutoRegressive Integrated Moving Average, is a forecasting algorithm based on the idea that the information in the past values of the time series can alone be used to predict the future values.\nARIMA Models are specified by three order parameters: (p, d, q),\n\nwhere,\n\n- p is the order of the AR term\n\n- d is the number of differencing required to make the time series stationary\n\n- q is the order of the MA term\n\n\n- AR(p) Autoregression – a regression model that utilizes the dependent relationship between a current observation and observations over a previous period. An auto regressive (AR(p)) component refers to the use of past values in the regression equation for the time series.\n\n- I(d) Integration – uses differencing of observations (subtracting an observation from observation at the previous time step) in order to make the time series stationary. Differencing involves the subtraction of the current values of a series with its previous values d number of times.\n\n- MA(q) Moving Average – a model that uses the dependency between an observation and a residual error from a moving average model applied to lagged observations. A moving average component depicts the error of the model as a combination of previous error terms. The order q represents the number of terms to be included in the model.","metadata":{"papermill":{"duration":0.453769,"end_time":"2022-06-19T13:11:19.871445","exception":false,"start_time":"2022-06-19T13:11:19.417676","status":"completed"},"tags":[]}},{"cell_type":"code","source":"# Get datasets\nif is_ARIMA:\n    train_ts, valid_ts, test_ts, train_valid_ts = get_train_valid_test_ts(df2.copy(), forecasting_days, target='Close')","metadata":{"papermill":{"duration":0.486799,"end_time":"2022-06-19T13:11:20.812025","exception":false,"start_time":"2022-06-19T13:11:20.325226","status":"completed"},"tags":[],"execution":{"iopub.status.busy":"2024-08-27T17:24:14.610449Z","iopub.status.idle":"2024-08-27T17:24:14.611035Z","shell.execute_reply.started":"2024-08-27T17:24:14.610724Z","shell.execute_reply":"2024-08-27T17:24:14.610754Z"},"trusted":true},"execution_count":null,"outputs":[]},{"cell_type":"markdown","source":"#### **5.2.1 How to find the order of differencing (d) in ARIMA model**  <a class=\"anchor\" id=\"5.2.1\"></a>\n\n[Table of Contents](#0.1)\n\nThis information from the good notebook [ARIMA Model for Time Series Forecasting](https://www.kaggle.com/code/prashant111/arima-model-for-time-series-forecasting)\n\n- As stated earlier, the purpose of differencing is to make the time series stationary. But we should be careful to not over-difference the series. An over differenced series may still be stationary, which in turn will affect the model parameters.\n\n\n- So we should determine the right order of differencing. The right order of differencing is the minimum differencing required to get a near-stationary series which roams around a defined mean and the ACF plot reaches to zero fairly quick.\n\n\n- If the autocorrelations are positive for many number of lags (10 or more), then the series needs further differencing. On the other hand, if the lag 1 autocorrelation itself is too negative, then the series is probably over-differenced.\n\n\n- If we can’t really decide between two orders of differencing, then we go with the order that gives the least standard deviation in the differenced series.\n\n\n- Now, we will explain these concepts with the help of an example as follows:\n\n\n- First, I will check if the series is stationary using the **Augmented Dickey Fuller test (ADF Test)**, from the statsmodels package. The reason being is that we need differencing only if the series is non-stationary. Else, no differencing is needed, that is, d=0.\n\n\n- The null hypothesis (Ho) of the ADF test is that the time series is non-stationary. So, if the p-value of the test is less than the significance level (0.05) then we reject the null hypothesis and infer that the time series is indeed stationary.\n\n\n- So, in our case, if P Value > 0.05 we go ahead with finding the order of differencing.\n\n- **A similar analysis has already been made in the paragraph \"3.4. Stationarity check\" above**","metadata":{"papermill":{"duration":0.449219,"end_time":"2022-06-19T13:11:21.710691","exception":false,"start_time":"2022-06-19T13:11:21.261472","status":"completed"},"tags":[]}},{"cell_type":"code","source":"def acf_pacf_draw(df, lag_num=40, acf=True, pacf=True, title=\"\", ylim=1):\n    # Draw plots named title with ACF and PACF for dataframe df\n    \n    num_plots = 1+int(acf)+int(pacf)\n    fig, ax = plt.subplots(1,num_plots,figsize=(12,6))\n    # 'Original Series'\n    ax[0].plot(df.values.squeeze())\n    \n    if acf:\n        # ACF drawing\n        plot_acf(df.values.squeeze(), lags=lag_num, ax=ax[1])\n        ax[1].set(ylim=(-ylim, ylim))\n        \n        if pacf:\n            # PACF drawing\n            plot_pacf(df.values.squeeze(), lags=lag_num, ax=ax[2])\n            ax[2].set(ylim=(-ylim, ylim))\n        \n    elif pacf:\n        # PACF drawing\n        plot_pacf(df.values.squeeze(), lags=lag_num, ax=ax[1])\n        ax[1].set(ylim=(-ylim, ylim))\n\n    fig.suptitle(title)\n    plt.show()","metadata":{"papermill":{"duration":0.463364,"end_time":"2022-06-19T13:11:22.625601","exception":false,"start_time":"2022-06-19T13:11:22.162237","status":"completed"},"tags":[],"execution":{"iopub.status.busy":"2024-08-27T17:24:14.612645Z","iopub.status.idle":"2024-08-27T17:24:14.613246Z","shell.execute_reply.started":"2024-08-27T17:24:14.612915Z","shell.execute_reply":"2024-08-27T17:24:14.612945Z"},"trusted":true},"execution_count":null,"outputs":[]},{"cell_type":"code","source":"if is_ARIMA:\n    # ACF and PACF\n    lag_num = 100\n    acf_pacf_draw(train_ts['y'], lag_num, True, True, 'Original Series')\n    acf_pacf_draw(train_ts['y'].diff().dropna(), lag_num, True, True, '1st Order Differencing')\n    acf_pacf_draw(train_ts['y'].diff().diff().dropna(), lag_num, True, True, '2nd Order Differencing')","metadata":{"papermill":{"duration":2.382718,"end_time":"2022-06-19T13:11:25.470663","exception":false,"start_time":"2022-06-19T13:11:23.087945","status":"completed"},"tags":[],"execution":{"iopub.status.busy":"2024-08-27T17:24:14.615187Z","iopub.status.idle":"2024-08-27T17:24:14.615767Z","shell.execute_reply.started":"2024-08-27T17:24:14.615455Z","shell.execute_reply":"2024-08-27T17:24:14.615486Z"},"trusted":true},"execution_count":null,"outputs":[]},{"cell_type":"markdown","source":"- For the above data, we can see that the time series reaches stationarity with first orders of differencing. Although, it value may be higher, as can be seen from the larger values of the lag.","metadata":{"papermill":{"duration":0.453465,"end_time":"2022-06-19T13:11:26.389278","exception":false,"start_time":"2022-06-19T13:11:25.935813","status":"completed"},"tags":[]}},{"cell_type":"code","source":"d = 1","metadata":{"papermill":{"duration":0.469893,"end_time":"2022-06-19T13:11:27.324904","exception":false,"start_time":"2022-06-19T13:11:26.855011","status":"completed"},"tags":[],"execution":{"iopub.status.busy":"2024-08-27T17:24:14.617055Z","iopub.status.idle":"2024-08-27T17:24:14.617571Z","shell.execute_reply.started":"2024-08-27T17:24:14.617330Z","shell.execute_reply":"2024-08-27T17:24:14.617354Z"},"trusted":true},"execution_count":null,"outputs":[]},{"cell_type":"markdown","source":"#### **5.2.2. How to find the order of the AR term (p)** <a class=\"anchor\" id=\"5.2.2\"></a>\n\n[Table of Contents](#0.1)\n\nThis information from the good notebook [ARIMA Model for Time Series Forecasting](https://www.kaggle.com/code/prashant111/arima-model-for-time-series-forecasting)\n\n- The next step is to identify if the model needs any AR terms. We will find out the required number of AR terms by inspecting the **Partial Autocorrelation (PACF) plot**.\n\n\n- **Partial autocorrelation** can be imagined as the correlation between the series and its lag, after excluding the contributions from the intermediate lags. So, PACF sort of conveys the pure correlation between a lag and the series. This way, we will know if that lag is needed in the AR term or not.\n\n\n- Partial autocorrelation of lag (k) of a series is the coefficient of that lag in the autoregression equation of Y.\n\n\n$$Yt = \\alpha0 + \\alpha1 Y{t-1} + \\alpha2 Y{t-2} + \\alpha3 Y{t-3}$$\n\n\n- That is, suppose, if Y_t is the current series and Y_t-1 is the lag 1 of Y, then the partial autocorrelation of lag 3 (Y_t-3) is the coefficient $\\alpha_3$ of Y_t-3 in the above equation.\n\n\n- Now, we should find the number of AR terms. Any autocorrelation in a stationarized series can be rectified by adding enough AR terms. So, we initially take the order of AR term to be equal to as many lags that crosses the significance limit in the PACF plot.\n\n","metadata":{"papermill":{"duration":0.460794,"end_time":"2022-06-19T13:11:28.246661","exception":false,"start_time":"2022-06-19T13:11:27.785867","status":"completed"},"tags":[]}},{"cell_type":"code","source":"# PACF drawing\nif is_ARIMA:\n    acf_pacf_draw(train_ts['y'].diff().dropna(), 30, False, True, '1st Order Differencing', 1)","metadata":{"papermill":{"duration":0.81716,"end_time":"2022-06-19T13:11:29.528212","exception":false,"start_time":"2022-06-19T13:11:28.711052","status":"completed"},"tags":[],"execution":{"iopub.status.busy":"2024-08-27T17:24:14.619106Z","iopub.status.idle":"2024-08-27T17:24:14.619545Z","shell.execute_reply.started":"2024-08-27T17:24:14.619335Z","shell.execute_reply":"2024-08-27T17:24:14.619359Z"},"trusted":true},"execution_count":null,"outputs":[]},{"cell_type":"markdown","source":"- We can see that the PACF lag 0 is quite significant since it is well above the significance line. So, we will fix the value of p as 1. Although, it value may be higher, as can be seen from the larger values of the lag.","metadata":{"papermill":{"duration":0.451163,"end_time":"2022-06-19T13:11:30.446485","exception":false,"start_time":"2022-06-19T13:11:29.995322","status":"completed"},"tags":[]}},{"cell_type":"code","source":"p = 0","metadata":{"papermill":{"duration":0.490108,"end_time":"2022-06-19T13:11:31.399991","exception":false,"start_time":"2022-06-19T13:11:30.909883","status":"completed"},"tags":[],"execution":{"iopub.status.busy":"2024-08-27T17:24:14.620736Z","iopub.status.idle":"2024-08-27T17:24:14.621197Z","shell.execute_reply.started":"2024-08-27T17:24:14.620956Z","shell.execute_reply":"2024-08-27T17:24:14.620979Z"},"trusted":true},"execution_count":null,"outputs":[]},{"cell_type":"markdown","source":"#### **5.2.3. How to find the order of the MA term (q)** <a class=\"anchor\" id=\"5.2.3\"></a>\n\n[Table of Contents](#0.1)\n\nThis information from the good notebook [ARIMA Model for Time Series Forecasting](https://www.kaggle.com/code/prashant111/arima-model-for-time-series-forecasting)\n\n- Just like how we looked at the PACF plot for the number of AR terms, we will look at the ACF plot for the number of MA terms. An MA term is technically, the error of the lagged forecast.\n\n\n- The ACF tells how many MA terms are required to remove any autocorrelation in the stationarized series.\n\n\n- Let’s see the autocorrelation plot of the differenced series.","metadata":{"papermill":{"duration":0.46211,"end_time":"2022-06-19T13:11:32.323318","exception":false,"start_time":"2022-06-19T13:11:31.861208","status":"completed"},"tags":[]}},{"cell_type":"code","source":"# ACF drawing\nif is_ARIMA:\n    acf_pacf_draw(train_ts['y'].diff().dropna(), 30, True, False, '1st Order Differencing', 1)","metadata":{"papermill":{"duration":0.815534,"end_time":"2022-06-19T13:11:33.602747","exception":false,"start_time":"2022-06-19T13:11:32.787213","status":"completed"},"tags":[],"execution":{"iopub.status.busy":"2024-08-27T17:24:14.623118Z","iopub.status.idle":"2024-08-27T17:24:14.623708Z","shell.execute_reply.started":"2024-08-27T17:24:14.623405Z","shell.execute_reply":"2024-08-27T17:24:14.623435Z"},"trusted":true},"execution_count":null,"outputs":[]},{"cell_type":"markdown","source":"- We can see that couple of lags are well above the significance line. So, we will fix q as 0. If there is any doubt, we will go with the simpler model that sufficiently explains the Y.","metadata":{"papermill":{"duration":0.460168,"end_time":"2022-06-19T13:11:34.534897","exception":false,"start_time":"2022-06-19T13:11:34.074729","status":"completed"},"tags":[]}},{"cell_type":"code","source":"q = 0","metadata":{"papermill":{"duration":0.467548,"end_time":"2022-06-19T13:11:35.463337","exception":false,"start_time":"2022-06-19T13:11:34.995789","status":"completed"},"tags":[],"execution":{"iopub.status.busy":"2024-08-27T17:24:14.626054Z","iopub.status.idle":"2024-08-27T17:24:14.626666Z","shell.execute_reply.started":"2024-08-27T17:24:14.626362Z","shell.execute_reply":"2024-08-27T17:24:14.626394Z"},"trusted":true},"execution_count":null,"outputs":[]},{"cell_type":"markdown","source":"#### **5.2.4. How to build the ARIMA Model with manually defined parameters** <a class=\"anchor\" id=\"5.2.4\"></a>\n\n\n[Table of Contents](#0.1)\n\n\nNow, we have determined the values of p, d and q. We have everything needed to fit the ARIMA model. We will use the ARIMA() implementation in the statsmodels package.","metadata":{"papermill":{"duration":0.465791,"end_time":"2022-06-19T13:11:36.390619","exception":false,"start_time":"2022-06-19T13:11:35.924828","status":"completed"},"tags":[]}},{"cell_type":"code","source":"def arima_fit(df, col, order=(1,1,1)):\n    # ARIMA model fitting for series df[col]\n    \n    model = sm.tsa.arima.ARIMA(df[col].values.squeeze(), order=order)\n    model = model.fit()\n    return model","metadata":{"papermill":{"duration":0.468141,"end_time":"2022-06-19T13:11:37.318717","exception":false,"start_time":"2022-06-19T13:11:36.850576","status":"completed"},"tags":[],"execution":{"iopub.status.busy":"2024-08-27T17:24:14.628420Z","iopub.status.idle":"2024-08-27T17:24:14.628993Z","shell.execute_reply.started":"2024-08-27T17:24:14.628694Z","shell.execute_reply":"2024-08-27T17:24:14.628723Z"},"trusted":true},"execution_count":null,"outputs":[]},{"cell_type":"code","source":"if is_ARIMA:\n    # ARIMA Model tuning\n    model = arima_fit(train_ts, 'y', order=(p,d,q))\n    print(model.summary())","metadata":{"papermill":{"duration":0.580544,"end_time":"2022-06-19T13:11:38.359925","exception":false,"start_time":"2022-06-19T13:11:37.779381","status":"completed"},"tags":[],"execution":{"iopub.status.busy":"2024-08-27T17:24:14.631044Z","iopub.status.idle":"2024-08-27T17:24:14.631662Z","shell.execute_reply.started":"2024-08-27T17:24:14.631360Z","shell.execute_reply":"2024-08-27T17:24:14.631390Z"},"trusted":true},"execution_count":null,"outputs":[]},{"cell_type":"markdown","source":"- The model summary provides lot of information. The table in the middle is the coefficients table where the values under ‘coef’ are the weights of the respective terms.\n\n- The model AIC has slightly reduced, which is good. The p-values  in ‘P>|z|’ column is highly significant (<< 0.05).","metadata":{"papermill":{"duration":0.454884,"end_time":"2022-06-19T13:11:39.296101","exception":false,"start_time":"2022-06-19T13:11:38.841217","status":"completed"},"tags":[]}},{"cell_type":"code","source":"if is_ARIMA:\n    # ARIMA model diagnostics\n    fig = model.plot_diagnostics(figsize=(12,10))\n    plt.show()","metadata":{"papermill":{"duration":1.126467,"end_time":"2022-06-19T13:11:40.885100","exception":false,"start_time":"2022-06-19T13:11:39.758633","status":"completed"},"tags":[],"execution":{"iopub.status.busy":"2024-08-27T17:24:14.633544Z","iopub.status.idle":"2024-08-27T17:24:14.634155Z","shell.execute_reply.started":"2024-08-27T17:24:14.633827Z","shell.execute_reply":"2024-08-27T17:24:14.633855Z"},"trusted":true},"execution_count":null,"outputs":[]},{"cell_type":"markdown","source":"#### **Interpretation of plots in plot diagnostics**\n\nThis information from the good notebook [ARIMA Model for Time Series Forecasting](https://www.kaggle.com/code/prashant111/arima-model-for-time-series-forecasting)\n\n**Standardized residual**: The residual errors seem to fluctuate around a mean of zero and have a uniform variance.\n\n\n**Histogram**: The density plot suggest normal distribution with mean slighlty shifted towards right.\n\n\n**Theoretical Quantiles**: Mostly the dots fall perfectly in line with the red line. Any significant deviations would imply the distribution is skewed.\n\n\n**Correlogram**: The Correlogram, (or ACF plot) shows the residual errors are not autocorrelated. The ACF plot would imply that there is some pattern in the residual errors which are not explained in the model. So we will need to look for more X’s (predictors) to the model.\n\n\nOverall, the model seems to be a good fit. Let’s plot the residuals to ensure there are no patterns (that is, look for constant mean and variance).","metadata":{"papermill":{"duration":0.541852,"end_time":"2022-06-19T13:11:41.905415","exception":false,"start_time":"2022-06-19T13:11:41.363563","status":"completed"},"tags":[]}},{"cell_type":"code","source":"def get_residual_errors(model):\n    # Calculation and drawing the plot residual errors for ARIMA model\n    residuals = pd.DataFrame(model.resid)\n    fig, ax = plt.subplots(1,2, figsize=(12,6))\n    residuals.plot(title=\"Residuals\", ax=ax[0])\n    residuals.plot(kind='kde', title='Density', ax=ax[1])\n    plt.show()","metadata":{"papermill":{"duration":0.475234,"end_time":"2022-06-19T13:11:42.862575","exception":false,"start_time":"2022-06-19T13:11:42.387341","status":"completed"},"tags":[],"execution":{"iopub.status.busy":"2024-08-27T17:24:14.635431Z","iopub.status.idle":"2024-08-27T17:24:14.636025Z","shell.execute_reply.started":"2024-08-27T17:24:14.635705Z","shell.execute_reply":"2024-08-27T17:24:14.635735Z"},"trusted":true},"execution_count":null,"outputs":[]},{"cell_type":"code","source":"if is_ARIMA:\n    # Plot residual errors\n    get_residual_errors(model)","metadata":{"papermill":{"duration":0.819564,"end_time":"2022-06-19T13:11:44.152916","exception":false,"start_time":"2022-06-19T13:11:43.333352","status":"completed"},"tags":[],"execution":{"iopub.status.busy":"2024-08-27T17:24:14.637973Z","iopub.status.idle":"2024-08-27T17:24:14.638605Z","shell.execute_reply.started":"2024-08-27T17:24:14.638300Z","shell.execute_reply":"2024-08-27T17:24:14.638331Z"},"trusted":true},"execution_count":null,"outputs":[]},{"cell_type":"markdown","source":"- The residual errors seem fine with near zero mean and uniform variance.","metadata":{"papermill":{"duration":0.461033,"end_time":"2022-06-19T13:11:45.090036","exception":false,"start_time":"2022-06-19T13:11:44.629003","status":"completed"},"tags":[]}},{"cell_type":"code","source":"def arima_forecasting(result, model, params, name_model, df, type_data):\n    # Data df (validation or test) forecasting on the num days by the model \n    # with params and save metrics to result \n    \n    ypred = model.forecast(steps=len(df))\n    \n    n = len(result)\n    result.loc[n,'name_model'] = name_model\n    result.loc[n,'type_data'] = type_data\n    result.at[n,'params'] = params\n    result.at[n,'ypred'] = ypred\n    #result = result_add_metrics(result, n, df['y'], y_pred)\n    \n    return result","metadata":{"papermill":{"duration":0.475306,"end_time":"2022-06-19T13:11:46.032472","exception":false,"start_time":"2022-06-19T13:11:45.557166","status":"completed"},"tags":[],"execution":{"iopub.status.busy":"2024-08-27T17:24:14.640173Z","iopub.status.idle":"2024-08-27T17:24:14.640658Z","shell.execute_reply.started":"2024-08-27T17:24:14.640407Z","shell.execute_reply":"2024-08-27T17:24:14.640430Z"},"trusted":true},"execution_count":null,"outputs":[]},{"cell_type":"code","source":"if is_ARIMA:\n    # Valid forecasting and save result\n    result = arima_forecasting(result, model, [p]+[d]+[q], 'ARIMA_manual', valid_ts, 'valid')","metadata":{"papermill":{"duration":0.475633,"end_time":"2022-06-19T13:11:46.971664","exception":false,"start_time":"2022-06-19T13:11:46.496031","status":"completed"},"tags":[],"execution":{"iopub.status.busy":"2024-08-27T17:24:14.643817Z","iopub.status.idle":"2024-08-27T17:24:14.644443Z","shell.execute_reply.started":"2024-08-27T17:24:14.644122Z","shell.execute_reply":"2024-08-27T17:24:14.644155Z"},"trusted":true},"execution_count":null,"outputs":[]},{"cell_type":"markdown","source":"#### **5.2.5. How to build the ARIMA automatically** <a class=\"anchor\" id=\"5.2.5\"></a>\n\n[Table of Contents](#0.1)","metadata":{"papermill":{"duration":0.463819,"end_time":"2022-06-19T13:11:47.902032","exception":false,"start_time":"2022-06-19T13:11:47.438213","status":"completed"},"tags":[]}},{"cell_type":"markdown","source":"You can try to use additional features in the parameter X of pm.auto_arima to improve forecasting, but this will be done in other notebooks later.","metadata":{"papermill":{"duration":0.464015,"end_time":"2022-06-19T13:11:48.834842","exception":false,"start_time":"2022-06-19T13:11:48.370827","status":"completed"},"tags":[]}},{"cell_type":"code","source":"%%time\nif is_ARIMA:\n    # Automatic tuning of the ARIMA model \n    model_auto = pm.auto_arima(train_ts['y'].values, \n                               start_p=4,        # start p\n                               start_q=4,        # start q\n                               test='adf',       # use adftest to find optimal 'd'\n                               max_p=5, max_q=5, # maximum p and q\n                               m=1,              # frequency of series (1 - No Seasonality)\n                               d=None,           # let model determine 'd'\n                               seasonal=False,   # No Seasonality\n                               start_P=0,        \n                               D=0, \n                               start_Q=0,\n                               trace=True,\n                               error_action='ignore',  \n                               suppress_warnings=False, \n                               stepwise=True     # use the stepwise algorithm outlined in Hyndman and Khandakar (2008) \n                                                 # to identify the optimal model parameters. \n                                                 # The stepwise algorithm can be significantly faster than fitting all \n                                                 # hyper-parameter combinations and is less likely to over-fit the model\n                              )\n\n    print(model_auto.summary())","metadata":{"papermill":{"duration":2.460202,"end_time":"2022-06-19T13:11:51.759979","exception":false,"start_time":"2022-06-19T13:11:49.299777","status":"completed"},"tags":[],"execution":{"iopub.status.busy":"2024-08-27T17:24:14.646497Z","iopub.status.idle":"2024-08-27T17:24:14.646943Z","shell.execute_reply.started":"2024-08-27T17:24:14.646721Z","shell.execute_reply":"2024-08-27T17:24:14.646742Z"},"trusted":true},"execution_count":null,"outputs":[]},{"cell_type":"code","source":"if is_ARIMA:\n    # Get orders of the best model from AutoARIMA\n    arima_orders_best = list(model_auto.get_params().get('order'))\n    print(f\"Optimal parameters are {arima_orders_best}\")\n    model_auto = arima_fit(train_ts, 'y', order=(arima_orders_best[0],arima_orders_best[1],arima_orders_best[2]))","metadata":{"papermill":{"duration":0.478262,"end_time":"2022-06-19T13:11:52.800005","exception":false,"start_time":"2022-06-19T13:11:52.321743","status":"completed"},"tags":[],"execution":{"iopub.status.busy":"2024-08-27T17:24:14.648670Z","iopub.status.idle":"2024-08-27T17:24:14.649152Z","shell.execute_reply.started":"2024-08-27T17:24:14.648904Z","shell.execute_reply":"2024-08-27T17:24:14.648927Z"},"trusted":true},"execution_count":null,"outputs":[]},{"cell_type":"code","source":"if is_ARIMA:\n    # Best model from AutoARIMA\n    fig = model_auto.plot_diagnostics(figsize=(12,10))\n    plt.show()","metadata":{"papermill":{"duration":1.057444,"end_time":"2022-06-19T13:11:54.329562","exception":false,"start_time":"2022-06-19T13:11:53.272118","status":"completed"},"tags":[],"execution":{"iopub.status.busy":"2024-08-27T17:24:14.650803Z","iopub.status.idle":"2024-08-27T17:24:14.651428Z","shell.execute_reply.started":"2024-08-27T17:24:14.651077Z","shell.execute_reply":"2024-08-27T17:24:14.651125Z"},"trusted":true},"execution_count":null,"outputs":[]},{"cell_type":"markdown","source":"- The residual errors seem fine with near zero mean and uniform variance.","metadata":{"papermill":{"duration":0.464361,"end_time":"2022-06-19T13:11:55.273117","exception":false,"start_time":"2022-06-19T13:11:54.808756","status":"completed"},"tags":[]}},{"cell_type":"code","source":"if is_ARIMA:\n    # Valid forecasting and save result\n    result = arima_forecasting(result, model_auto, arima_orders_best, 'ARIMA_auto', valid_ts, 'valid')","metadata":{"papermill":{"duration":0.486538,"end_time":"2022-06-19T13:11:56.229602","exception":false,"start_time":"2022-06-19T13:11:55.743064","status":"completed"},"tags":[],"execution":{"iopub.status.busy":"2024-08-27T17:24:14.653684Z","iopub.status.idle":"2024-08-27T17:24:14.654190Z","shell.execute_reply.started":"2024-08-27T17:24:14.653904Z","shell.execute_reply":"2024-08-27T17:24:14.653956Z"},"trusted":true},"execution_count":null,"outputs":[]},{"cell_type":"markdown","source":"### 5.3. Other ML models (Multi-factors models) <a class=\"anchor\" id=\"5.3\"></a>\n\n[Back to Table of Contents](#0.1)","metadata":{"papermill":{"duration":0.476312,"end_time":"2022-06-19T13:11:57.176628","exception":false,"start_time":"2022-06-19T13:11:56.700316","status":"completed"},"tags":[]}},{"cell_type":"markdown","source":"This section provides examples of identifying the following models (but the list goes on):\n* Linear Regression\n* KNeighbors Regressor\n* Support Vector Machines\n* Linear SVR\n* Random Forest Regressor\n* Bagging Regressor\n* XGB Regressor\n* MLP Regressor\n\nClassic model XGBoost have a special format, but this notebook  uses its simplified version, which work in a data format similar to the models of the Sklearn library.\n\nModels based on neural networks (based on PyTorch or Keras) and ensembles of all these models are more effective, but this will be done later in other notebooks.\n\n**This section - from the notebook [Crypto - BTC : 7 prediction models](https://www.kaggle.com/code/vbmokin/crypto-btc-7-prediction-models)**","metadata":{"papermill":{"duration":0.470542,"end_time":"2022-06-19T13:11:58.119208","exception":false,"start_time":"2022-06-19T13:11:57.648666","status":"completed"},"tags":[]}},{"cell_type":"code","source":"# Get datasets\nif is_other_ML:\n    df2 = get_target_mf(df2, forecasting_days, col='Close')\n    train_mf, ytrain_mf, valid_mf, yvalid_mf, test_mf, ytest_mf, train_valid_mf, y_train_valid_mf, starting_point = \\\n                                    get_train_valid_test_mf(df2.copy(), forecasting_days, target='target')","metadata":{"papermill":{"duration":0.495078,"end_time":"2022-06-19T13:11:59.083384","exception":false,"start_time":"2022-06-19T13:11:58.588306","status":"completed"},"tags":[],"execution":{"iopub.status.busy":"2024-08-27T17:24:14.655657Z","iopub.status.idle":"2024-08-27T17:24:14.656139Z","shell.execute_reply.started":"2024-08-27T17:24:14.655877Z","shell.execute_reply":"2024-08-27T17:24:14.655898Z"},"trusted":true},"execution_count":null,"outputs":[]},{"cell_type":"markdown","source":"#### **5.3.1. Set parameters for many models** <a class=\"anchor\" id=\"5.3.1\"></a>\n\n[Table of Contents](#0.1)","metadata":{"papermill":{"duration":0.466643,"end_time":"2022-06-19T13:12:00.020914","exception":false,"start_time":"2022-06-19T13:11:59.554271","status":"completed"},"tags":[]}},{"cell_type":"markdown","source":"**TASK:** Try adding more models or changing the settings of these models.","metadata":{"papermill":{"duration":0.469896,"end_time":"2022-06-19T13:12:00.960359","exception":false,"start_time":"2022-06-19T13:12:00.490463","status":"completed"},"tags":[]}},{"cell_type":"code","source":"if is_other_ML:\n    # Set parameters of models\n    models = pd.DataFrame(columns = ['name', 'model', 'param_grid'])\n\n    # Linear Regression\n    n = len(models)\n    models.loc[n, 'name'] = 'Linear Regression'\n    models.at[n, 'model'] = LinearRegression()\n    models.at[n, 'param_grid'] = {'fit_intercept' : [True, False]}\n\n\n    # KNeighbors Regressor\n    n = len(models)\n    models.loc[n, 'name'] = 'KNeighbors Regressor'\n    models.at[n, 'model'] = KNeighborsRegressor()\n    models.at[n, 'param_grid'] = {'n_neighbors': [3, 5, 10, 20, 30],\n                                  'leaf_size': [10, 20, 30]\n                                 }\n\n    # Support Vector Machines\n    n = len(models)\n    models.loc[n, 'name'] = 'Support Vector Machines'\n    models.at[n, 'model'] = SVR()\n    models.at[n, 'param_grid'] = {'kernel': ['linear', 'poly', 'rbf', 'sigmoid'],\n                                  'C': np.linspace(1, 15, 15),\n                                  'tol': [1e-3, 1e-4]\n                                 }\n\n    # Linear SVC\n    n = len(models)\n    models.loc[n, 'name'] = 'Linear SVR'\n    models.at[n, 'model'] = LinearSVR()\n    models.at[n, 'param_grid'] = {'C': np.linspace(1, 15, 15)}\n\n\n    # Random Forest Classifier\n    n = len(models)\n    models.loc[n, 'name'] = 'Random Forest Regressor'\n    models.at[n, 'model'] = RandomForestRegressor()\n    models.at[n, 'param_grid'] = {'n_estimators': [40, 50, 60, 80], \n                                  'min_samples_split': [30, 40, 50, 60], \n                                  'min_samples_leaf': [10, 12, 15, 20, 50],\n                                  'max_features': ['auto'], \n                                  'max_depth': [3, 4, 5, 6]                   \n                                 }\n\n    # Bagging Classifier\n    n = len(models)\n    models.loc[n, 'name'] = 'Bagging Regressor'\n    models.at[n, 'model'] = BaggingRegressor()\n    models.at[n, 'param_grid'] = {'max_features': np.linspace(0.05, 0.8, 1),\n                                  'n_estimators': [3, 4, 5, 6],\n                                  'warm_start' : [False]\n                                 }\n\n    # XGB Classifier\n    n = len(models)\n    models.loc[n, 'name'] = 'XGB Regressor'\n    models.at[n, 'model'] = xgb.XGBRegressor()\n    models.at[n, 'param_grid'] = {'n_estimators': [50, 70, 90], \n                                  'learning_rate': [0.01, 0.05, 0.1, 0.2],\n                                  'max_depth': [3, 4, 5]\n                                 }\n\n    # MLP Classifier\n    n = len(models)\n    models.loc[n, 'name'] = 'MLP Regressor'\n    models.at[n, 'model'] = MLPRegressor()\n    models.at[n, 'param_grid'] = {'hidden_layer_sizes': [i for i in range(2,5)],\n                                  'solver': ['lbfgs', 'sgd'],\n                                  'learning_rate': ['adaptive'],\n                                  'learning_rate_init': [0.001, 0.01],\n                                  'max_iter': [1000]\n                                 }\nmodels","metadata":{"papermill":{"duration":0.531429,"end_time":"2022-06-19T13:12:01.964535","exception":false,"start_time":"2022-06-19T13:12:01.433106","status":"completed"},"tags":[],"execution":{"iopub.status.busy":"2024-08-27T17:24:14.658046Z","iopub.status.idle":"2024-08-27T17:24:14.658505Z","shell.execute_reply.started":"2024-08-27T17:24:14.658292Z","shell.execute_reply":"2024-08-27T17:24:14.658315Z"},"trusted":true},"execution_count":null,"outputs":[]},{"cell_type":"markdown","source":"#### **5.3.2. Models training and forecasting** <a class=\"anchor\" id=\"5.3.2\"></a>\n\n[Table of Contents](#0.1)","metadata":{"papermill":{"duration":0.459808,"end_time":"2022-06-19T13:12:02.903099","exception":false,"start_time":"2022-06-19T13:12:02.443291","status":"completed"},"tags":[]}},{"cell_type":"code","source":"def model_prediction(result, models, train_features, valid_features, train_labels, valid_labels):    \n    # Models training and data prediction for all models from DataFrame models\n    # Saving results for validation dataset into dataframe result\n    \n    def calc_add_score(res, n, type_score, list_true, list_pred, feature_end):\n        # Calculation score with type=type_score for list_true and list_pred \n        # Adding score into res.loc[n,...]\n        res.loc[i, type_score + feature_end] = calc_metrics(type_score, list_true, list_pred)\n        return res\n    \n    # Results\n    model_all = []\n\n    for i in range(len(models)):\n        # Training\n        print(f\"Tuning model '{models.loc[i, 'name']}'\")\n        model = GridSearchCV(models.at[i, 'model'], models.at[i, 'param_grid'])\n        model.fit(train_features, train_labels)\n        model_all.append(model)\n        print(f\"Best parameters: {model.best_params_}\\n\")\n        \n        # Prediction\n        ypred = model.predict(valid_features)\n        \n        # Scoring and saving results into the main dataframe result\n        n = len(result)\n        result.loc[n,'name_model'] = f\"{models.loc[i, 'name']}\"\n        result.loc[n,'type_data'] = \"valid\"\n        result.at[n,'params'] = model.best_params_\n        result.at[n,'ypred'] = ypred\n        #result = result_add_metrics(result, n, valid_labels, valid_pred)\n        \n    return result, model_all","metadata":{"papermill":{"duration":0.487088,"end_time":"2022-06-19T13:12:03.868497","exception":false,"start_time":"2022-06-19T13:12:03.381409","status":"completed"},"tags":[],"execution":{"iopub.status.busy":"2024-08-27T17:24:14.659952Z","iopub.status.idle":"2024-08-27T17:24:14.660429Z","shell.execute_reply.started":"2024-08-27T17:24:14.660194Z","shell.execute_reply":"2024-08-27T17:24:14.660217Z"},"trusted":true},"execution_count":null,"outputs":[]},{"cell_type":"code","source":"%%time\nif is_other_ML:\n    # Models tuning and the forecasting\n    result, model_all = model_prediction(result, models, train_mf, valid_mf, ytrain_mf, yvalid_mf)","metadata":{"papermill":{"duration":367.139906,"end_time":"2022-06-19T13:18:11.496668","exception":false,"start_time":"2022-06-19T13:12:04.356762","status":"completed"},"tags":[],"execution":{"iopub.status.busy":"2024-08-27T17:24:14.661538Z","iopub.status.idle":"2024-08-27T17:24:14.661973Z","shell.execute_reply.started":"2024-08-27T17:24:14.661754Z","shell.execute_reply":"2024-08-27T17:24:14.661776Z"},"trusted":true},"execution_count":null,"outputs":[]},{"cell_type":"markdown","source":"### 5.4. Choosing the main optimal model and forecasting <a class=\"anchor\" id=\"5.4\"></a>\n\n[Back to Table of Contents](#0.1)","metadata":{"papermill":{"duration":0.487521,"end_time":"2022-06-19T13:18:12.466572","exception":false,"start_time":"2022-06-19T13:18:11.979051","status":"completed"},"tags":[]}},{"cell_type":"code","source":"def recovery_prediction(y, starting_point):\n    # Recovering prediction of multi-factors model for shifted col_diff to col in the dataframe df\n    # y has type np.array\n    # starting_point is dictionary with start values for the recovering data\n    # Returns y (np.array) with recovering data\n    \n    return np.insert(y, 0, starting_point).cumsum()[1:]","metadata":{"papermill":{"duration":0.49445,"end_time":"2022-06-19T13:18:13.446052","exception":false,"start_time":"2022-06-19T13:18:12.951602","status":"completed"},"tags":[],"execution":{"iopub.status.busy":"2024-08-27T17:24:14.664031Z","iopub.status.idle":"2024-08-27T17:24:14.664514Z","shell.execute_reply.started":"2024-08-27T17:24:14.664294Z","shell.execute_reply":"2024-08-27T17:24:14.664317Z"},"trusted":true},"execution_count":null,"outputs":[]},{"cell_type":"code","source":"def result_recover_and_metrics(result, df_ts, type_data, start_points):\n    # Recovering prediction: from shifted_Close_diff to Close\n    # Calculation metrics for recovering ypred forecasting for all models in result\n    # ypred real is from df_ts['y']\n    # start points value for the recovering is from dictionary start_points\n    # type_data = 'valid' or 'test'\n\n    for i in range(len(result)):\n        if (result.loc[i, 'type_data']==type_data) and (result.loc[i, 'mape'] is np.nan):\n            ypred = result.loc[i, 'ypred']\n\n            # Recovering ypred for multi-factors models\n            if not (str(result.loc[i, 'type_model']) in ['Prophet', 'ARIMA']):\n                # Multi-factors model\n                # Get start points value for the recovering\n                start_point_value = start_points['valid_start_point'] if type_data=='valid' else start_points['test_start_point']\n                # Recovering prediction\n                ypred = recovery_prediction(ypred, start_point_value)            \n\n            # Calculation metrics\n            result = result_add_metrics(result, i, df_ts['y'], ypred)\n    \n    return result","metadata":{"papermill":{"duration":0.488483,"end_time":"2022-06-19T13:18:14.400992","exception":false,"start_time":"2022-06-19T13:18:13.912509","status":"completed"},"tags":[],"execution":{"iopub.status.busy":"2024-08-27T17:24:14.666159Z","iopub.status.idle":"2024-08-27T17:24:14.666602Z","shell.execute_reply.started":"2024-08-27T17:24:14.666387Z","shell.execute_reply":"2024-08-27T17:24:14.666409Z"},"trusted":true},"execution_count":null,"outputs":[]},{"cell_type":"code","source":"# Dispay and save all results for validation dataset\nif len(result) > 0:\n    \n    # Get type of each model\n    result['type_model'] = result['name_model'].str.split('_').str[0]\n\n    # Calculation metrics for recovering prediction ypred for validation dataset by all models \n    result = result_recover_and_metrics(result, valid_ts, 'valid', starting_point)\n    display(result[['name_model', 'type_data', 'r2_score', 'rmse', 'mape']].sort_values(by=['type_data', 'mape', 'rmse'], ascending=True))\n    \n    # Save results\n    num_models = len(result[result['type_data']=='valid']['name_model'].unique().tolist())\n    print(f\"Number of models built - {num_models}\")\n    result.to_csv(f'result_of_{num_models}_models_for_forecasting_days_{forecasting_days}.csv')\nelse: \n    print('There are no tuned models!')","metadata":{"papermill":{"duration":0.553432,"end_time":"2022-06-19T13:18:15.429906","exception":false,"start_time":"2022-06-19T13:18:14.876474","status":"completed"},"tags":[],"execution":{"iopub.status.busy":"2024-08-27T17:24:14.667716Z","iopub.status.idle":"2024-08-27T17:24:14.668153Z","shell.execute_reply.started":"2024-08-27T17:24:14.667917Z","shell.execute_reply":"2024-08-27T17:24:14.667938Z"},"trusted":true},"execution_count":null,"outputs":[]},{"cell_type":"code","source":"def get_model_opt(name_model, params):\n    # Model tuning for the name_model\n    \n    print(name_model)\n    if name_model=='Linear Regression':\n        model = LinearRegression(**params)\n        \n    elif name_model=='KNeighbors Regressor':\n        model = KNeighborsRegressor(**params)\n        \n    elif name_model=='Support Vector Machines':\n        model = SVR(**params)\n        \n    elif name_model=='Linear SVR':\n        model = LinearSVR(**params)\n        \n    elif name_model=='Random Forest Regressor':\n        model = RandomForestRegressor(**params)\n        \n    elif name_model=='Bagging Regressor':\n        model = BaggingRegressor(**params)\n    \n    elif name_model=='MLP Regressor':\n        model = MLPRegressor(**params)\n        \n    elif name_model=='XGB Regressor':\n        model = xgb.XGBRegressor(**params)\n        \n    else: model = None\n        \n    return model","metadata":{"papermill":{"duration":0.484112,"end_time":"2022-06-19T13:18:16.398990","exception":false,"start_time":"2022-06-19T13:18:15.914878","status":"completed"},"tags":[],"execution":{"iopub.status.busy":"2024-08-27T17:24:14.669352Z","iopub.status.idle":"2024-08-27T17:24:14.669771Z","shell.execute_reply.started":"2024-08-27T17:24:14.669560Z","shell.execute_reply":"2024-08-27T17:24:14.669582Z"},"trusted":true},"execution_count":null,"outputs":[]},{"cell_type":"code","source":"def get_params_optimal_model(result, main_metrics):\n    # Get parameters of the optimal model from dataframe result by main_metrics\n\n    # Set the data type to float (just in case)\n    result[main_metrics] = result[main_metrics].astype('float')\n    \n    # Choose the optimal model\n    opt_result = result[result['type_data']=='valid'].reset_index(drop=True)\n    if main_metrics=='r2_score':\n        opt_model = opt_result.nlargest(1, main_metrics)\n    else:\n        # 'mape' or 'rmse'\n        opt_model = opt_result.nsmallest(1, main_metrics)\n    display(opt_model[['name_model', 'r2_score', 'rmse', 'mape', 'params']])\n\n    # Get parameters of the optimal model\n    opt_name_model = opt_model['name_model'].tolist()[0]\n    opt_type_model = opt_model['type_model'].tolist()[0]\n    opt_params_model = opt_model['params'].tolist()[0]\n    print(f'Optimal model by metrics \"{main_metrics}\" is \"{opt_name_model}\" with type \"{opt_type_model}\" parameters {opt_params_model}')\n    \n    return opt_name_model, opt_type_model, opt_params_model","metadata":{"papermill":{"duration":0.501718,"end_time":"2022-06-19T13:18:17.377578","exception":false,"start_time":"2022-06-19T13:18:16.875860","status":"completed"},"tags":[],"execution":{"iopub.status.busy":"2024-08-27T17:24:14.670911Z","iopub.status.idle":"2024-08-27T17:24:14.671618Z","shell.execute_reply.started":"2024-08-27T17:24:14.671398Z","shell.execute_reply":"2024-08-27T17:24:14.671421Z"},"trusted":true},"execution_count":null,"outputs":[]},{"cell_type":"code","source":"def model_training_forecasting(result, df, y, test, ytest,  \n                               name_model, type_model, params, type_test='1'):\n    # Model training for df and y\n    # Forecasting ypred\n    # type_model = 'Prophet' or \"ARIMA\" or 'Other ML'\n    # type_test = '1' (with find optimal parameters by GridSearchCV) \n    # type_test = '2' (with optimal parameters - without GridSearchCV)\n    # return params and metrics in the dataframe result\n    \n    if type_model=='Prophet':    \n        season_days_optimal = params[0]\n        fourier_order_seasonality_optimal = params[1]\n        model_opt = None\n        _, ypred = prophet_modeling(result, \n                                    cryptocurrency, \n                                    df, \n                                    test, \n                                    holidays_df, \n                                    season_days_optimal,\n                                    fourier_order_seasonality_optimal,\n                                    forecasting_days,\n                                    f'{type_model}_optimal',\n                                    'test')        \n    elif type_model=='ARIMA':\n        season_days_optimal = params[0]\n        fourier_order_seasonality_optimal = params[1]        \n        model_opt = None\n        \n        # Training ARIMA optimal model for training+valid dataset\n        df['y'] = y\n        model_opt = arima_fit(df, 'y', order=(params[0],params[1],params[2]))        \n\n        # Model diagnostics\n        fig = model_opt.plot_diagnostics(figsize=(12,10))\n        plt.show()\n\n        # Plot residual errors\n        get_residual_errors(model_opt)\n\n        # Test forecasting and save result\n        ypred = model_opt.forecast(steps=len(test))        \n\n    else:\n        # Other ML model\n        # Training ML optimal model for training+valid dataset\n        print(f\"Tuning model '{name_model}'\")\n        models_opt_number = models[models['name']==name_model].index.tolist()[0]\n        #print(f\"Model - {models.at[models_opt_number,'model']} with parameters {params}\")\n        if type_test=='1':\n            model_opt = GridSearchCV(models.at[models_opt_number,'model'], models.at[models_opt_number,'param_grid'])\n        else:\n            # type_test=='2'\n            model_opt = get_model_opt(models.at[models_opt_number,'name'], params)\n        model_opt.fit(df, y)\n        \n        # Forecasting\n        ypred = model_opt.predict(test)\n\n        \n    # Scoring and saving results into the dataframe result\n    n = len(result)-1\n    result.loc[n,'name_model'] = f\"{type_model}_optimal\"\n    result.loc[n,'type_data'] = \"test\"\n    result.loc[n,'type_model'] = type_model\n    result.at[n,'params'] = params\n    result.at[n,'ypred'] = ypred\n    #result = result_add_metrics(result, n, ytest, ypred)\n    \n    return result, model_opt, ypred","metadata":{"papermill":{"duration":0.519352,"end_time":"2022-06-19T13:18:18.375827","exception":false,"start_time":"2022-06-19T13:18:17.856475","status":"completed"},"tags":[],"execution":{"iopub.status.busy":"2024-08-27T17:24:14.673479Z","iopub.status.idle":"2024-08-27T17:24:14.673906Z","shell.execute_reply.started":"2024-08-27T17:24:14.673689Z","shell.execute_reply":"2024-08-27T17:24:14.673710Z"},"trusted":true},"execution_count":null,"outputs":[]},{"cell_type":"code","source":"def get_optimal_model_and_forecasting(result, main_metrics, start_points):\n    # Choosion the optimal model from dataframe result by main_metrics\n    # Tuning optimal model for big dataset train+valid \n    # Test forecasting and drawing it\n    # Returns the optimal model and it's name\n\n    \n    if len(result) > 0:\n        # Get parameters of the optimal model from dataframe result by main_metrics\n        opt_name_model, opt_type_model, opt_params_model = get_params_optimal_model(result, \n                                                                                    main_metrics)\n        # Set datasets for the final tuning and testing by optimal model\n        if (opt_type_model=='Prophet') or (opt_type_model=='ARIMA'):\n            train_valid = train_valid_ts.copy()\n            y_train_valid = train_valid_ts['y'].copy()\n            test = test_ts.copy()\n            ytest = test_ts['y'].copy()\n            \n        else:\n            # Multi-factors ML models\n            train_valid = train_valid_mf.copy()\n            y_train_valid = y_train_valid_mf.copy()\n            test = test_mf.copy()\n            ytest = ytest_mf.copy()\n    \n        # Optimal model training for train+valid and test forecasting\n        result, model_opt, ypred = model_training_forecasting(result, train_valid, y_train_valid,\n                                                              test, ytest,\n                                                              opt_name_model, opt_type_model, \n                                                              opt_params_model, '1')\n        \n        # Calculation metrics for recovering prediction ypred for test dataset by the optimal model\n        result = result_recover_and_metrics(result, test_ts, 'test', start_points)\n        \n        # Drawing plot for prediction for the test data \n        if not ((opt_type_model=='Prophet') or (opt_type_model=='ARIMA')):\n            # Recovery values \"Close\"\n            ytest_plot = recovery_prediction(ytest.values, start_points['test_start_point'])\n            ypred_plot = recovery_prediction(ypred, start_points['test_start_point'])\n        else:\n            ytest_plot = ytest.copy()\n            ypred_plot = ypred.copy()\n            \n        # Drawing \n        plt.figure(figsize=(12,8))\n        x = np.arange(len(ytest_plot))\n        plt.scatter(x, ytest_plot, label = \"Target test data\", color = 'g', s=100)\n        plt.scatter(x, ypred_plot, label = f\"{opt_name_model} forecasting\", color = 'r', s=50)\n        plt.title(f'Forecasting of test data using the \"{opt_name_model}\" model, which is optimal for \"{main_metrics}\" metrics')\n        plt.ylim(0)\n        plt.legend(loc='lower right')\n        plt.grid(True)\n        \n        return opt_name_model","metadata":{"papermill":{"duration":0.533595,"end_time":"2022-06-19T13:18:19.432758","exception":false,"start_time":"2022-06-19T13:18:18.899163","status":"completed"},"tags":[],"execution":{"iopub.status.busy":"2024-08-27T17:24:14.675860Z","iopub.status.idle":"2024-08-27T17:24:14.676325Z","shell.execute_reply.started":"2024-08-27T17:24:14.676079Z","shell.execute_reply":"2024-08-27T17:24:14.676121Z"},"trusted":true},"execution_count":null,"outputs":[]},{"cell_type":"code","source":"result","metadata":{"papermill":{"duration":0.527524,"end_time":"2022-06-19T13:18:20.477461","exception":false,"start_time":"2022-06-19T13:18:19.949937","status":"completed"},"tags":[],"execution":{"iopub.status.busy":"2024-08-27T17:24:14.677672Z","iopub.status.idle":"2024-08-27T17:24:14.678111Z","shell.execute_reply.started":"2024-08-27T17:24:14.677875Z","shell.execute_reply":"2024-08-27T17:24:14.677897Z"},"trusted":true},"execution_count":null,"outputs":[]},{"cell_type":"code","source":"# Get the optimal model by different metrics\nif len(result) > 0:\n    for valid_metrics in ['r2_score', 'rmse', 'mape']:\n        get_optimal_model_and_forecasting(result, valid_metrics, starting_point)    ","metadata":{"papermill":{"duration":594.354032,"end_time":"2022-06-19T13:28:15.333800","exception":false,"start_time":"2022-06-19T13:18:20.979768","status":"completed"},"tags":[],"execution":{"iopub.status.busy":"2024-08-27T17:24:14.679762Z","iopub.status.idle":"2024-08-27T17:24:14.680226Z","shell.execute_reply.started":"2024-08-27T17:24:14.679970Z","shell.execute_reply":"2024-08-27T17:24:14.679999Z"},"trusted":true},"execution_count":null,"outputs":[]},{"cell_type":"markdown","source":"### 5.5. Feature importance study <a class=\"anchor\" id=\"5.5\"></a>\n\n[Back to Table of Contents](#0.1)","metadata":{"papermill":{"duration":0.482488,"end_time":"2022-06-19T13:28:16.312112","exception":false,"start_time":"2022-06-19T13:28:15.829624","status":"completed"},"tags":[]}},{"cell_type":"markdown","source":"A feature importance study is performed for the best of the \"non Тime Series\" models, as no additional features were used in the Time Series models.","metadata":{"papermill":{"duration":0.478149,"end_time":"2022-06-19T13:28:17.283406","exception":false,"start_time":"2022-06-19T13:28:16.805257","status":"completed"},"tags":[]}},{"cell_type":"code","source":"# Training ML optimal model for training+valid dataset\n# Get parameters of the optimal model from dataframe result (without Time Series models) by main_metrics\nif is_other_ML:\n    main_metrics = 'r2_score'\n    if (len(result) > 0) and (len(models) > 0):\n        result_nonTS = result[(result['type_model']!='Prophet') & (result['type_model']!='ARIMA')].reset_index(drop=True)\n        opt_name_model2, opt_type_model2, opt_params_model2 = get_params_optimal_model(result_nonTS, \n                                                                                main_metrics)\n\n        result, model_opt, ypred = model_training_forecasting(result, \n                                                              train_valid_mf, \n                                                              y_train_valid_mf,\n                                                              test_mf, \n                                                              ytest_mf,\n                                                              opt_name_model2, \n                                                              opt_type_model2, \n                                                              opt_params_model2, \n                                                              '2')","metadata":{"papermill":{"duration":0.731339,"end_time":"2022-06-19T13:28:18.502494","exception":false,"start_time":"2022-06-19T13:28:17.771155","status":"completed"},"tags":[],"execution":{"iopub.status.busy":"2024-08-27T17:24:14.681359Z","iopub.status.idle":"2024-08-27T17:24:14.681754Z","shell.execute_reply.started":"2024-08-27T17:24:14.681552Z","shell.execute_reply":"2024-08-27T17:24:14.681572Z"},"trusted":true},"execution_count":null,"outputs":[]},{"cell_type":"code","source":"# All features names\nif is_other_ML:\n    coeff = pd.DataFrame(train_valid_mf.columns)\n    coeff.columns = ['feature']","metadata":{"papermill":{"duration":0.490034,"end_time":"2022-06-19T13:28:19.492768","exception":false,"start_time":"2022-06-19T13:28:19.002734","status":"completed"},"tags":[],"execution":{"iopub.status.busy":"2024-08-27T17:24:14.683543Z","iopub.status.idle":"2024-08-27T17:24:14.684020Z","shell.execute_reply.started":"2024-08-27T17:24:14.683761Z","shell.execute_reply":"2024-08-27T17:24:14.683782Z"},"trusted":true},"execution_count":null,"outputs":[]},{"cell_type":"code","source":"def add_fi_coeff(coeff, col, list_new_fi_coeff=None, df_new_fi_coeff=None):\n    # Adds new importance of features as feature col\n    # from list list_new_fi_coeff or dataframe df_new_fi_coeff\n    # to the resulting dataframe coeff with feature names \n    # Missed importance values are replaced by zero\n    \n    if list_new_fi_coeff is not None:\n        df_new_fi_coeff = coeff[['feature']].copy()\n        df_new_fi_coeff[\"score\"] = pd.Series(list_new_fi_coeff)\n    \n    if df_new_fi_coeff is not None:\n        # Rename df_new_fi_coeff\n        df_new_fi_coeff.columns = ['feature', 'score']   # to the plot drawing\n        df_new_fi_coeff[col] = df_new_fi_coeff['score']  # to the merging and saving\n        \n        # Merging dataframes - coeff of all features with new_fi_coeff\n        coeff = coeff.merge(df_new_fi_coeff[['feature', col]], on='feature', how='left').fillna(0)\n        \n        is_score = True\n    else:\n        print(f'Data is absent fol {col}')\n        is_score = False\n        coeff = None\n    \n    return coeff, df_new_fi_coeff, is_score","metadata":{"papermill":{"duration":0.4991,"end_time":"2022-06-19T13:28:20.484906","exception":false,"start_time":"2022-06-19T13:28:19.985806","status":"completed"},"tags":[],"execution":{"iopub.status.busy":"2024-08-27T17:24:14.685597Z","iopub.status.idle":"2024-08-27T17:24:14.686021Z","shell.execute_reply.started":"2024-08-27T17:24:14.685794Z","shell.execute_reply":"2024-08-27T17:24:14.685815Z"},"trusted":true},"execution_count":null,"outputs":[]},{"cell_type":"code","source":"# Feature importance diagram with SHAP\nif is_other_ML:\n    if (len(result) > 0) and (len(models) > 0):\n        print('Feature importance diagram with SHAP:')\n        try:\n            # Trees\n            explainer = shap.TreeExplainer(model_opt)\n            shap_values = explainer.shap_values(test_mf)\n            shap.summary_plot(shap_values, test_mf, plot_type=\"bar\", feature_names=coeff['feature'].tolist())\n            shap.summary_plot(shap_values, test_mf)\n\n            # Save permutation feature importance values\n            coeff, _, is_SHAP_successfully = add_fi_coeff(coeff, 'shap_fi_score', shap_values)\n        except: \n            try:\n                # Other types of models\n                explainer = shap.KernelExplainer(model_opt.predict, train_valid_mf)\n                shap_values = explainer.shap_values(test_mf)\n\n                # Plot drawing\n                shap.summary_plot(shap_values, test_mf, plot_type=\"bar\", feature_names=coeff['feature'].tolist())\n                shap.summary_plot(shap_values, test_mf)\n\n                # Get feature importance values from shap_values format\n                # Thanks to https://stackoverflow.com/a/69523421/12301574\n                shap_values_all = pd.DataFrame(shap_values, columns = test_mf.columns)\n                vals = np.abs(shap_values_all.values).mean(0)\n                shap_importance = pd.DataFrame(list(zip(test_mf.columns, vals)),\n                                                  columns=['feature','score'])            \n\n                # Saving feature importance values\n                coeff, _, is_SHAP_successfully = add_fi_coeff(coeff, 'shap_fi_score', None, shap_importance)            \n\n            except: \n                is_SHAP_successfully = False\n\n        if not is_SHAP_successfully:\n            print('Feature importance diagram for this optimal model is not supported in SHAP')","metadata":{"papermill":{"duration":70.177963,"end_time":"2022-06-19T13:29:31.152777","exception":false,"start_time":"2022-06-19T13:28:20.974814","status":"completed"},"tags":[],"execution":{"iopub.status.busy":"2024-08-27T17:24:14.687445Z","iopub.status.idle":"2024-08-27T17:24:14.687859Z","shell.execute_reply.started":"2024-08-27T17:24:14.687650Z","shell.execute_reply":"2024-08-27T17:24:14.687672Z"},"trusted":true},"execution_count":null,"outputs":[]},{"cell_type":"code","source":"# Force plot - Feature importance diagram with SHAP for the certaion row in test_mf\nif is_other_ML:\n    if (len(result) > 0) and (len(models) > 0):\n        row_number_in_test_mf = 0\n        print('Feature importance diagram as the Force plot with SHAP:')\n        if is_SHAP_successfully:\n            shap.initjs()\n            shap.force_plot(explainer.expected_value, shap_values[0,:], \n                            test_mf.loc[test_mf.index.tolist()[row_number_in_test_mf],:],\n                            feature_names=coeff['feature'].tolist(),\n                            matplotlib=True, show=False)\n            plt.savefig('force_plot.png')","metadata":{"papermill":{"duration":1.902536,"end_time":"2022-06-19T13:29:33.570029","exception":false,"start_time":"2022-06-19T13:29:31.667493","status":"completed"},"tags":[],"execution":{"iopub.status.busy":"2024-08-27T17:24:14.689884Z","iopub.status.idle":"2024-08-27T17:24:14.690498Z","shell.execute_reply.started":"2024-08-27T17:24:14.690187Z","shell.execute_reply":"2024-08-27T17:24:14.690217Z"},"trusted":true},"execution_count":null,"outputs":[]},{"cell_type":"code","source":"# Creation and drawing the feature importance diagrams\nif is_other_ML:\n    if (len(result) > 0) and (len(models) > 0):\n\n        # Coefficients\n        if opt_name_model2=='XGB Regressor':\n            print('Feature importance diagram')\n            # Coef. of the feature with nonzero importance\n            xgb_coeff = pd.DataFrame.from_dict(model_opt.get_booster().get_score(importance_type='weight'), orient='index').reset_index(drop=False)\n            coeff, _, is_score = add_fi_coeff(coeff, 'xgb_fi_coeff', None, xgb_coeff)\n\n            # With the library xgboost\n            fig =  plt.figure(figsize = (15,15))\n            axes = fig.add_subplot(111)\n            xgb.plot_importance(model_opt,ax = axes,height = 0.5)\n            plt.show()\n            plt.close()\n\n        else:\n            # With the library sklearn\n            try:\n                coef_model = model_opt.coef_\n                coeff, coeff_new, is_score = add_fi_coeff(coeff, 'lr_fi_score', coef_model)\n            except:\n                try:\n                    coef_model = feature_importances_\n                    coeff, coeff_new, is_score = add_fi_coeff(coeff, 'model_fi_score', coef_model)\n                except: \n                    print('The importance of the feature could not be obtained')\n                    is_score = False\n\n            if is_score:\n                # Plot drawing\n                coeff_non_zero = coeff_new[coeff_new['score']>0]\n                plt.figure(figsize=(12, int(len(coeff_non_zero)*0.4)))\n                coeff_non_zero = coeff_non_zero.sort_values(by='score', ascending=True)\n                plt.barh(coeff_non_zero[\"feature\"], coeff_non_zero[\"score\"])\n                plt.title(\"Feature importance diagram\")\n                plt.axvline(x=0, color=\".5\")\n                plt.xlabel(\"Coefficient values\")\n                plt.subplots_adjust(left=0.3)","metadata":{"papermill":{"duration":0.540526,"end_time":"2022-06-19T13:29:34.659532","exception":false,"start_time":"2022-06-19T13:29:34.119006","status":"completed"},"tags":[],"execution":{"iopub.status.busy":"2024-08-27T17:24:14.692548Z","iopub.status.idle":"2024-08-27T17:24:14.693164Z","shell.execute_reply.started":"2024-08-27T17:24:14.692819Z","shell.execute_reply":"2024-08-27T17:24:14.692851Z"},"trusted":true},"execution_count":null,"outputs":[]},{"cell_type":"code","source":"# Permutation feature importance diagram\nif is_other_ML:\n    if (len(result) > 0) and (len(models) > 0):\n        try:\n            perm_importance = permutation_importance(model_opt, test_mf, ytest_mf)\n\n            # Save permutation feature importance values\n            coef_model = perm_importance.importances_mean\n            coeff, coeff_new, is_score = add_fi_coeff(coeff, 'perm_fi_score', coef_model)\n\n            print('Permutation feature importance diagram:') \n            coeff_non_zero = coeff_new[coeff_new['score'].abs()>1e-4]\n            coeff_non_zero = coeff_non_zero.sort_values(by='score', ascending=True)\n            plt.figure(figsize=(12, int(len(coeff_non_zero)*0.4)))\n            plt.barh(coeff_non_zero[\"feature\"], coeff_non_zero[\"score\"])\n            plt.xlabel(\"Permutation Importance\")\n            plt.show()\n            is_perm_importance = True\n        except: print('Permutation feature importance diagram for this optimal model is not supported')","metadata":{"papermill":{"duration":3.635338,"end_time":"2022-06-19T13:29:38.813258","exception":false,"start_time":"2022-06-19T13:29:35.177920","status":"completed"},"tags":[],"execution":{"iopub.status.busy":"2024-08-27T17:24:14.695020Z","iopub.status.idle":"2024-08-27T17:24:14.695616Z","shell.execute_reply.started":"2024-08-27T17:24:14.695315Z","shell.execute_reply":"2024-08-27T17:24:14.695344Z"},"trusted":true},"execution_count":null,"outputs":[]},{"cell_type":"code","source":"# Feature importance diagram with ELI5\nif is_other_ML:\n    if (len(result) > 0) and (len(models) > 0):\n        try:\n            print('Feature importance diagram with ELI5:')\n            perm = PermutationImportance(model_opt).fit(test_mf,ytest_mf)\n\n            # Save permutation feature importance values\n            coef_model = perm.feature_importances_  # Feature importances, \n                                                    # computed as mean decrease \n                                                    # of the score when a feature \n                                                    # is permuted (i.e. becomes noise)\n            coeff, _, is_score = add_fi_coeff(coeff, 'eli5_perm_fi_score', coef_model)\n\n            # Display permutation feature importance values with ELI5\n            display(eli5.show_weights(perm, feature_names = coeff.feature.tolist()))\n\n        except: print('Feature importance diagram for this optimal model is not supported in ELI5')","metadata":{"papermill":{"duration":3.501639,"end_time":"2022-06-19T13:29:42.837456","exception":false,"start_time":"2022-06-19T13:29:39.335817","status":"completed"},"tags":[],"execution":{"iopub.status.busy":"2024-08-27T17:24:14.697359Z","iopub.status.idle":"2024-08-27T17:24:14.697917Z","shell.execute_reply.started":"2024-08-27T17:24:14.697626Z","shell.execute_reply":"2024-08-27T17:24:14.697655Z"},"trusted":true},"execution_count":null,"outputs":[]},{"cell_type":"code","source":"# Display and saving features importance values\nif is_other_ML:\n    if coeff.isna().sum().sum()==0:\n        print('Feature importance values:')\n        fi_cols = coeff.columns.tolist()[1:]\n        if len(fi_cols) > 0:\n            coeff = coeff.sort_values(by=fi_cols, ascending=False)\n            display(coeff)\n        coeff.to_csv(f'feature_importance_for_optimal_model_{opt_name_model2}.csv', index=False)","metadata":{"papermill":{"duration":0.554937,"end_time":"2022-06-19T13:29:43.919715","exception":false,"start_time":"2022-06-19T13:29:43.364778","status":"completed"},"tags":[],"execution":{"iopub.status.busy":"2024-08-27T17:24:14.699332Z","iopub.status.idle":"2024-08-27T17:24:14.699906Z","shell.execute_reply.started":"2024-08-27T17:24:14.699608Z","shell.execute_reply":"2024-08-27T17:24:14.699638Z"},"trusted":true},"execution_count":null,"outputs":[]},{"cell_type":"markdown","source":"I hope you find this notebook useful and enjoyable.\n\nYour comments and feedback are most welcome.","metadata":{"papermill":{"duration":0.514548,"end_time":"2022-06-19T13:29:44.954884","exception":false,"start_time":"2022-06-19T13:29:44.440336","status":"completed"},"tags":[]}},{"cell_type":"markdown","source":"[Go to Top](#0)","metadata":{"papermill":{"duration":0.515597,"end_time":"2022-06-19T13:29:45.991961","exception":false,"start_time":"2022-06-19T13:29:45.476364","status":"completed"},"tags":[]}}]}